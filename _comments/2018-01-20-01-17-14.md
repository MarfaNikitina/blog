---
id: 3716766821
is_spam: false
is_deleted: false
post: /oop-2/
date: 2018-01-20T01:17:14Z
author_fullname: 'Kapralov Sergey'
author_nickname: 'skapral'
author_is_anon: false
---

<p>&gt; Как я уже писал, появляется потребность в особом знании о том, как организовать<br>такие классы. Напрашивается идея о “схлопывании” такого дерева в отдельный<br>объект-копировальщик, какой-нибудь DataCopier, что, конечно, противоречит<br>тезисам Егора. Как тут быть, я не знаю.</p><p>Если дополнить принципы ЕО немного отсебятинкой, то можно очень просто схлапывать куски любой композиционной пирамидки в отдельные реюзабельные модули, не теряя преимуществ ЕО. Например вот так:</p><p><a href="https://github.com/project-avral/oo-atom/blob/master/atom-basis/src/main/java/oo/atom/codegen/bytebuddy/bt/BtApplyAtomPatch.java" rel="nofollow noopener" title="https://github.com/project-avral/oo-atom/blob/master/atom-basis/src/main/java/oo/atom/codegen/bytebuddy/bt/BtApplyAtomPatch.java">https://github.com/project-...</a></p><p>Принцип прост:</p><p>1. Правило "класс может быть абстрактным либо финальным" заменяем правилом: "класс может содержать только финальные методы, но сам не должен быть финальным".<br>2. Позволяем наследовать классы, но с важным условием. Наследник ни в коем случае не должен добавлять новых свойств, методов, имплементировать новые интерфейсы. Разрешены только новые конструкторы.</p><p>В этом случае наследник обладает интересными свойствами. Он и родитель не просто взаимозаменяемы по LSP, они идентичны (разве что за исклюлчением имени класса, что не имеет значения пока не используется рефлексия и instanceof). Контент каплинга не происходит - наследник просто не имеет средств завязаться на родителя где то кроме как на его конструктор. Профит же в том что наследник записывается в клиентском коде компактнее чем пирамидка которую он замещает.</p>
