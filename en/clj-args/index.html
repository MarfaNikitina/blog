<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>On Clojure arguments</title>
  <meta name="description" content="Sometimes, a function that we are working on needs to take lots ofparameters. Not just one or two but a decade or even more. I used to face withsuch a proble...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="http://grishaev.me/en/clj-args/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="http://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

</head>


  <body>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-33533163-2', 'auto');
    ga('send', 'pageview');

</script>

    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container" style="justify-content: space-between">

                <div>
                    <div class="flex-container">
                        <p style="margin-bottom: 5px">
                            Ivan Grishaev's blog
                            <br>
                            <small>Writing on programming, education, books and negotiations.
</small>
                        </p>
                    </div>
                </div>

                <div>
                    
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search"
      itemprop="potentialAction"
      itemtype="http://schema.org/SearchAction">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>

                </div>

            </div>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">On Clojure arguments</h1>
    <p class="post-meta">
      <time datetime="2017-06-23T00:00:00+00:00" itemprop="datePublished">Jun 23, 2017</time>

      

      <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/programming/" rel="tag">programming</a>, <a href="/tag/arguments/" rel="tag">arguments</a>
    </p>

    <script src="https://yastatic.net/es5-shims/0.0.2/es5-shims.min.js"></script>
<script src="https://yastatic.net/share2/share.js"></script>
<div class="ya-share2" data-services="twitter,telegram,facebook,vkontakte,lj,evernote,linkedin,reddit" data-limit="4"></div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Sometimes, a function that we are working on needs to take lots of
parameters. Not just one or two but a decade or even more. I used to face with
such a problem many times. I’m not sure solutions made by me were always good
enough.</p>

<p>You might be brave enough to say you will never face such an error. It’s
probably a weird architecture. A function should accepts at least five
arguments. You will refactor such a code for sure.</p>

<p>But look at this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">max_length</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">blank</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">null</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">db_index</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">NOT_PROVIDED</span><span class="p">,</span> <span class="n">editable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">serialize</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">unique_for_date</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">unique_for_month</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">unique_for_year</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">help_text</span><span class="o">=</span><span class="s">''</span><span class="p">,</span> <span class="n">db_column</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">db_tablespace</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">auto_created</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">validators</span><span class="o">=</span><span class="p">(),</span>
                 <span class="n">error_messages</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</code></pre></div></div>

<p>It is <a href="https://github.com/django/django/blob/master/django/db/models/fields/__init__.py#L134">from Django</a>, the world-wide spreaded framework to build robust
web applications. Except <code class="highlighter-rouge">self</code>, the constructor takes 22 optional
arguments. Saying more, it is just a basic abstract class. Its descendants
require their own arguments in addition to default ones.</p>

<p>Common languages such as Python, Ruby or Java give only one standard way to deal
with lots of parameters. In fact, using them you cannot be mistaken since you
have no other choice. The question here is how to make you code less ugly than
it is now.</p>

<p>People who are new in Clojure, especially if they came from classical
Python/Puby/PHP, face troubles when passing lots of arguments into a
function. Since it’s Clojure, there are several ways to do that. This article
highlights some on them, their benefits and disadvantages.</p>

<h3 id="multi-arity">Multi-arity</h3>

<p>Any function in Clojure may have more than one body with its own
signature. That’s normal for any functional language, but sounds surprisingly to
former Python/Ruby adepts. An interpreter dispatches that bodies by a form of
arguments. The first found body is called. When no body is found, an exception
is raised.</p>

<p>For example, the same function could be called with either two or three
arguments if we declare it in such way:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo</span><span class="w">
 </span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"two arguments"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">
 </span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"three arguments!"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">foo</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="mi">3</span><span class="w"> </span><span class="c1">;; prints `two arguments`</span><span class="w">

</span><span class="p">(</span><span class="nf">foo</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mi">6</span><span class="w"> </span><span class="c1">;; prints `three arguments!`</span><span class="w">
</span></code></pre></div></div>

<p>Calling a function with zero, one or ten arguments will raise an
exception. Depending on your application’s logic, it could be both good or bad
behaviour.</p>

<p>To fallback to default body that deals with any set of arguments, add one more
implementation:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo</span><span class="w">
 </span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
   </span><span class="n">...</span><span class="w">
  </span><span class="p">)</span><span class="w">
 </span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="p">)</span><span class="w">
 </span><span class="p">([</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">args</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Now, you may add any arguments set together:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">foo</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="mi">10</span><span class="w">

</span><span class="p">(</span><span class="nf">foo</span><span class="p">)</span><span class="w">
</span><span class="mi">0</span><span class="w">
</span></code></pre></div></div>

<p>The order of bodies is important. If you put <code class="highlighter-rouge">[&amp; args]</code> clause on the top, it
will cover all the possible function calls. So you will never reach <code class="highlighter-rouge">[x y]</code> or
<code class="highlighter-rouge">[x y z]</code> implementations.</p>

<p>One interesting feature is you may redirect function call inside a body just
calling the same function with another argument set. For example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">test</span><span class="w">
  </span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nb">test</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w"> </span><span class="c1">;; redirects to the second body</span><span class="w">
  </span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">do-some-stuff</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Clojure dispatches a proper body quite fast. It is a key feature of Clojure’s
runtime. There are lots of core functions that declare two, three or even five
bodies regarding to performance issues. It’s much faster then having a single
body with multiple <code class="highlighter-rouge">if</code>s, <code class="highlighter-rouge">case</code> or <code class="highlighter-rouge">cond</code>clauses.</p>

<p>A quick copy-paste from <a href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj#L2556">Clojure sources</a>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">juxt</span><span class="w">
  </span><span class="s">"..."</span><span class="w">
  </span><span class="p">([</span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
  </span><span class="p">([</span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
  </span><span class="p">([</span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">h</span><span class="p">]</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
  </span><span class="p">([</span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">fs</span><span class="p">]</span><span class="w"> </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Multi-arity is great when you already have a function that takes a couple of
scalar parameters and then you need to add some extra one ASAP. Usually, the
most needed function is called in thousand places so adding an extra parameter
everywhere would be a mess.</p>

<p>In Java or Python world, it is named “refactoring”. You need a robust commercial
IDE to scan the project and change each call of a function. In Clojure, you just
do:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; old</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">test</span><span class="w">
  </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">do-old-stuff</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">

</span><span class="c1">;; new</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">test</span><span class="w">
  </span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">do-old-stuff</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">do-new-stuff</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">do-old-stuff</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Now you can keep the old calls without changing your code. And pass the new
argument only where you need.</p>

<h3 id="maps">Maps</h3>

<p>Your function may need lots of additional arguments. For example, boolean flags,
extra options for HTTP connection, timeouts, headers, error messages.</p>

<p>A good way to solve the problem is to join them into a single map. Thus, your
function accepts only a couple of required parameters and the rest are put into
an optional map. Say, you pass a hostname and a method name and a map with
<code class="highlighter-rouge">:timeout</code>, <code class="highlighter-rouge">:headers</code> keys on so on.</p>

<p>Inside a function, you either take optional arguments one by one:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">[</span><span class="n">hostname</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">opt</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">timeout</span><span class="w"> </span><span class="p">(</span><span class="no">:timeout</span><span class="w"> </span><span class="n">opt</span><span class="p">)</span><span class="w">
        </span><span class="n">headers</span><span class="w"> </span><span class="p">(</span><span class="no">:headers</span><span class="w"> </span><span class="n">opt</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">http-request</span><span class="w"> </span><span class="n">hostname</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="n">headers</span><span class="p">)</span><span class="w">
    </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>or decompose a map on separated variables at once:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">[</span><span class="n">hostname</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">opt</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">timeout</span><span class="w">
                </span><span class="n">headers</span><span class="p">]}</span><span class="w"> </span><span class="n">opt</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">http-request</span><span class="w"> </span><span class="n">hostname</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="n">headers</span><span class="p">)</span><span class="w">
    </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Decomposition works as well on the signature level. I do not like this method
though since it brings some noise in the code:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">[</span><span class="n">hostname</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[{</span><span class="n">timeout</span><span class="w"> </span><span class="no">:timeout</span><span class="w">
                             </span><span class="n">headers</span><span class="w"> </span><span class="no">:headers</span><span class="p">}]]</span><span class="w">
  </span><span class="p">(</span><span class="nf">http-request</span><span class="w"> </span><span class="n">hostname</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="n">headers</span><span class="p">)</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>A good point there is you may keep a default map somewhere and merge it with the
passed ones to fallback to default values:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">foo-defaults</span><span class="w">
  </span><span class="p">{</span><span class="no">:timeout</span><span class="w"> </span><span class="mi">5</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:user-agent</span><span class="w"> </span><span class="s">"Internet Explorer 6.0"</span><span class="p">}})</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">[</span><span class="n">hostname</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">opt</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">timeout</span><span class="w">
                </span><span class="n">headers</span><span class="p">]}</span><span class="w"> </span><span class="p">(</span><span class="nb">merge</span><span class="w"> </span><span class="n">foo-defaults</span><span class="w"> </span><span class="n">opt</span><span class="p">)]</span><span class="w">
    </span><span class="c1">;; now timeout is always 5 when not passed</span><span class="w">
    </span><span class="n">...</span><span class="w">
    </span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>This way of passing a map is widely-spreaded across Clojure libraries. It even
considered as the standard one because of its simplicity and transparency. If
you have just started with Clojure and need a function with multiple arguments,
use a map.</p>

<h3 id="rest-arguments-as-a-map">Rest arguments as a map</h3>

<p>There is another way to deal with multiple arguments. Do you remember the <code class="highlighter-rouge">rest</code>
arguments prepended with <code class="highlighter-rouge">&amp;</code> in a function signature? Something like that:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="c1">;; args is a list)</span><span class="w">

</span><span class="p">(</span><span class="nf">foo</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">;; args is (1 2 3 4)</span><span class="w">
</span></code></pre></div></div>

<p>Starting with Clojure 1.5 (or 1.6, I don’t remember exactly) you may turn the
rest arguments into a map. The syntax is:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span><span class="no">:as</span><span class="w"> </span><span class="n">args</span><span class="p">}]</span><span class="w">
  </span><span class="c1">;; now, args is a map!</span><span class="w">
  </span><span class="n">args</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">foo</span><span class="w"> </span><span class="no">:foo</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:bar</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:bar</span><span class="w"> </span><span class="mi">42</span><span class="n">,</span><span class="w"> </span><span class="no">:foo</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Pass extra arguments remembering some simple rules:</p>

<ol>
  <li>there must be even number of rest arguments, otherwise you will get an error;</li>
  <li>each odd argument (usually a keyword) is a key;</li>
  <li>each even argument is a value;</li>
  <li>you cannot duplicate key items.</li>
</ol>

<p>Turning rest arguments into a map is also used oftenly in Clojure. You may
choose that method over a map as well when developing with Clojure.</p>

<h3 id="pure-map-vs-rest-args">Pure map vs rest args</h3>

<p>Each of two method described above has its own benefits and disadvantages. Let’s
highlight some of them:</p>

<ol>
  <li>
    <p>Using a map is good when you don’t know exactly what arguments you will pass
into a function. It’s a common situation when the final set of options is
unknown for the last moment. It might depend on user input, environment
variables or any conditions. Usually, you compose a map step by step, validate
it with somehow and pass into a function. With sequences, it’s more difficult
to compose a set of arguments.</p>
  </li>
  <li>
    <p>Passing a map into a function with the <code class="highlighter-rouge">&amp; rest</code> signature requires some
additional steps. You should flatten you map into a vector or sequence and
then apply it to a function:</p>

    <div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">opt</span><span class="w"> </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="no">:bar</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]})</span><span class="w"> </span><span class="c1">;; your options map</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span><span class="no">:as</span><span class="w"> </span><span class="n">args</span><span class="p">}]</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="c1">;; but the function accepts rest arguments</span><span class="w">

</span><span class="c1">;; turns opt to a seq of (key1 val1 key2 val2)</span><span class="w">
</span><span class="c1">;; then apply it to the function</span><span class="w">
</span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="nb">identity</span><span class="w"> </span><span class="n">opt</span><span class="p">))</span><span class="w">
</span></code></pre></div>    </div>

    <p>Note how long is the code. Probably, you’d better to modify the function to
accept just map.</p>
  </li>
  <li>
    <p>With the rest arguments, <code class="highlighter-rouge">partial</code> works like a charm. Say, we have a
function that returns a set of rows from the database. The first argument is
a table name, and the rest are a sequence with each odd argument as a column
name and even argument as a value:</p>

    <div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">db-query</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="no">:active</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="no">:staff</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; performs a query like:</span><span class="w">
</span><span class="c1">;; select *</span><span class="w">
</span><span class="c1">;;   from "users"</span><span class="w">
</span><span class="c1">;; where</span><span class="w">
</span><span class="c1">;;   active</span><span class="w">
</span><span class="c1">;;   and staff</span><span class="w">
</span><span class="c1">;;   and name = "Ivan"</span><span class="w">
</span></code></pre></div>    </div>

    <p>Some of our users could be blocked. We may forget passing <code class="highlighter-rouge">:active false</code>
clause every time you query for users. To prevent returning blocked ones to
the frontend, it’s better to have a special function for that:</p>

    <div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">active-users</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">db-query</span><span class="w"> </span><span class="no">:users</span><span class="w"> </span><span class="no">:active</span><span class="w"> </span><span class="n">true</span><span class="p">))</span><span class="w">
</span></code></pre></div>    </div>

    <p>In addition to this constraint, we might be interested in only staff
users. Let’s extend our function with another partial application:</p>

    <div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">staff-active-users</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">active-users</span><span class="w"> </span><span class="no">:staff</span><span class="w"> </span><span class="n">true</span><span class="p">))</span><span class="w">
</span></code></pre></div>    </div>

    <p>Finally, we may select all the non-blocked staff users whose name is Ivan:</p>

    <div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">staff-active-users</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Ivan"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [{:id 1 :name "Ivan" :surname "Petrov"}</span><span class="w">
</span><span class="c1">;;  {:id 1 :name "Ivan" :surname "Sidorov"}]</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>Instead, with maps you cannot declare a partial function. You need to invent
your own <code class="highlighter-rouge">partial-map</code> implementation:</p>

    <div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
</span><span class="c1">;; let `foo` is a function that accepts a map</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="w">
  </span><span class="n">opt</span><span class="p">)</span><span class="w">

</span><span class="c1">;; our own `partial`</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">partial-map</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="w"> </span><span class="n">defaults</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="nb">merge</span><span class="w"> </span><span class="n">defaults</span><span class="w"> </span><span class="n">opt</span><span class="p">))))</span><span class="w">

</span><span class="c1">;; example:</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">foo-timeout</span><span class="w"> </span><span class="p">(</span><span class="nf">partial-map</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span><span class="no">:timeout</span><span class="w"> </span><span class="mi">5</span><span class="p">}))</span><span class="w">

</span><span class="p">(</span><span class="nf">foo-timeout</span><span class="w"> </span><span class="p">{</span><span class="no">:bar</span><span class="w"> </span><span class="mi">42</span><span class="p">})</span><span class="w">
</span><span class="p">{</span><span class="no">:bar</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="no">:timeout</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ol>

<h3 id="conclusion">Conclusion</h3>

<p>The examples above show there are more then one way to deal with multiple
arguments in Clojure. These are multi-arity, maps and rest arguments. All of
them cover you common requirements as well.</p>

<p>Remember, you are not limited with the only three those ones. With macroses, you
can implement you own arguments system: Common Lisp-wise or any other. The only
limit there is your imagination.</p>

  </div>

</article>

<div id="disqus_thread"></div>
<script>
    /**
    * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
    */
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');

    s.src = '//igrishaev.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/igrishaev"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">igrishaev</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/i_grishaev"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">i_grishaev</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
