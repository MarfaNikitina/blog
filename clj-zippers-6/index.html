<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Зипперы в Clojure (часть 6). Виртуальные деревья. Обмен валют</title>
  <meta name="description" content="Оглавление  Зипперы (часть 1). Азы навигации  Зипперы (часть 2). Автонавигация  Зипперы (часть 3). XML-зипперы  Зипперы (часть 4). Поиск в XML  Зипперы (част...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-zippers-6/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Зипперы в Clojure (часть 6). Виртуальные деревья. Обмен валют</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2020-08-12T00:00:00+00:00">
        Aug 12, 2020
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/zippers/" rel="tag">zippers</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="оглавление">Оглавление</h2>

<ul>
  <li><a href="/clj-zippers-1/">Зипперы (часть 1). Азы навигации</a></li>
  <li><a href="/clj-zippers-2/">Зипперы (часть 2). Автонавигация</a></li>
  <li><a href="/clj-zippers-3/">Зипперы (часть 3). XML-зипперы</a></li>
  <li><a href="/clj-zippers-4/">Зипперы (часть 4). Поиск в XML</a></li>
  <li><a href="/clj-zippers-5/">Зипперы (часть 5). Редактирование</a></li>
  <li><a href="/clj-zippers-6/">Зипперы (часть 6). Виртуальные деревья. Обмен валют</a></li>
  <li><a href="/clj-zippers-7/">Зипперы (часть 7). Обход в ширину. Улучшенный обмен валют</a></li>
  <li><a href="/clj-zippers-8/">Зипперы (часть 8). Заключение</a></li>
</ul>

<p>Предыдущих занятий было достаточно, чтобы перейти к экспериментам над
зипперами. Предлагаем читателю подумать над необычным примером.</p>

<p>До сих пор вторая функция, которую мы передавали в зиппер, возвращала потомков
из ветки. Для вектора это была просто <code class="language-plaintext highlighter-rouge">seq</code>, для XML — более сложная комбинация
<code class="language-plaintext highlighter-rouge">(comp seq :content)</code>. Оба варианта отталкиваются от родительского узла, и если
потомков нет, функция вернёт <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p>Но что если функция вернёт постоянный набор потомков:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>Как поведёт себя такой зиппер? Напишем его:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">zip-123</span><span class="w">
  </span><span class="p">(</span><span class="nf">zip/zipper</span><span class="w"> </span><span class="n">any?</span><span class="w">
              </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]))</span><span class="w">
              </span><span class="n">nil</span><span class="w">
              </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<!-- more -->

<p>Из-за того, что у каждого элемента три потомка, зиппер станет бесконечным. Обойти
его с помощью <code class="language-plaintext highlighter-rouge">iter-zip</code> не получится — <code class="language-plaintext highlighter-rouge">zip/next</code> будет всё глубже погружаться
в зиппер, но не достигнет его конца.</p>

<p>Ради интереса сделаем несколько шагов по новому зипперу. Спустимся вниз и
вправо. Мы окажемся на двойке в середине вектора <code class="language-plaintext highlighter-rouge">[1 2 3]</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-2</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">zip-123</span><span class="w">
      </span><span class="n">zip/down</span><span class="w">
      </span><span class="n">zip/right</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc-2</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 2</span><span class="w">
</span></code></pre></div></div>

<p>Покажем наше положение не схеме. Шаги влево и право сдвинут нас на единицу и
тройку:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │     1     │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │[1 2 3]│
                └───────┘
</code></pre></div></div>

<p>С шагом вниз мы провалимся в очередной вектор <code class="language-plaintext highlighter-rouge">[1 2 3]</code> и так далее. Ради
интереса спустимся вниз и вправо пять раз, и всё равно окажемся в двойке:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">down-right</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="n">zip/right</span><span class="w"> </span><span class="n">zip/down</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc-2</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">down-right</span><span class="w">
    </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 2</span><span class="w">
</span></code></pre></div></div>

<p>Зиппер можно назвать виртуальным, потому что данных, по которым мы путешествуем,
на самом деле не существует — они появляются в полёте.</p>

<p>Пока что неясно, в чём польза от этого зиппера. Но он подтверждает важный тезис
— можно получать потомков в процессе обхода дерева. Это не нарушает правила
зипперов и даёт новые возможности.</p>

<p>Однако заданный явно вектор <code class="language-plaintext highlighter-rouge">[1 2 3]</code> не раскрывает их. Если потомки известны
заранее, нужда в зиппере отпадает — коллекцию можно обойти более простым
способом. Интересен случай, когда потомки зависят от каких-то внешних
факторов. Например, обе функции <code class="language-plaintext highlighter-rouge">branch?</code> и <code class="language-plaintext highlighter-rouge">children</code> замкнуты на других
коллекциях и данных. Это тоже обход, но по другим правилам.</p>

<p>Рассмотрим следующую задачу. Банк разменивает валюты, например доллары на евро,
рубли на лиры и так далее. Для краткости обозначим их парами: <code class="language-plaintext highlighter-rouge">(usd, eur)</code>,
<code class="language-plaintext highlighter-rouge">(rub, lir)</code>. Размен действует в одном направлении: чтобы поменять евро на
доллары или лиры на рубли, у банка должны быть отдельные правила <code class="language-plaintext highlighter-rouge">(eur, usd)</code> и
<code class="language-plaintext highlighter-rouge">(lir, rub)</code>.</p>

<p>В банк обращается клиент, чтобы разменять валюту <code class="language-plaintext highlighter-rouge">X</code> на <code class="language-plaintext highlighter-rouge">Y</code>. Если в правилах
обмена есть пара <code class="language-plaintext highlighter-rouge">(X, Y)</code>, проблемы не возникает. Но если пары нет, банк должен
построить цепочку обменов. Например, клиент хочет поменять доллары на лиры, но в
банке нет прямой пары <code class="language-plaintext highlighter-rouge">(usd, lir)</code>. Однако есть пары <code class="language-plaintext highlighter-rouge">(usd, eur)</code> и <code class="language-plaintext highlighter-rouge">(eur,
lir)</code>. В этом случае клиенту предложат обмен <code class="language-plaintext highlighter-rouge">usd -&gt; eur -&gt; lir</code>.</p>

<p>Ваша задача — написать программу, которая принимает правила обмена, входную и
выходную валюты. Вы должны найти цепочки обмена. Чем короче цепочка, тем
лучше. Если возможны несколько цепочек одинаковой длины, вернуть их все, чтобы
клиент мог выбирать. Учесть, что решений может не быть и адекватно реагировать
на этот случай: не уйти в вечный цикл, не занимать все ресурсы компьютера.</p>

<p>Опишем входные данные в терминах Clojure. Каждое правило будет вектором двух
кейвордов — с какой валюты на какую происходит обмен. Вектор правил назовем
<code class="language-plaintext highlighter-rouge">rules</code>. Кроме правил, мы принимаем параметры <code class="language-plaintext highlighter-rouge">from</code> и <code class="language-plaintext highlighter-rouge">to</code> с какой и на какую
валюту менять.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; rules</span><span class="w">
</span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:lir</span><span class="p">]]</span><span class="w">

</span><span class="no">:usd</span><span class="w"> </span><span class="c1">;; from</span><span class="w">
</span><span class="no">:rub</span><span class="w"> </span><span class="c1">;; to</span><span class="w">
</span></code></pre></div></div>

<p>На выходе ожидаем набор цепочек от <code class="language-plaintext highlighter-rouge">from</code> к <code class="language-plaintext highlighter-rouge">to</code> или <code class="language-plaintext highlighter-rouge">nil</code>. Для случая выше
цепочка от доллара к евро выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Всё вместе даёт функцию <code class="language-plaintext highlighter-rouge">exchanges</code>, тело которой нам предстоит заполнить:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">exchanges</span><span class="w"> </span><span class="p">[</span><span class="n">rules</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">to</span><span class="p">]</span><span class="w">
  </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Для начала напишем несколько тестов. Они помогут размяться, и заодно мы лучше
поймем задачу. Первый тест — простой обмен, который есть среди правил:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-simple</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w">
         </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Обмен в обратную сторону невозможен, если нет обратного правила:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-reverse-err</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:usd</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Случай, когда цепочки обмена не существует:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-no-solution</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:usd</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:eur</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Наиболее важный сценарий: множественный обмен. От долларов к рублям можно дойти
двумя путями – с евро и лирами в середине:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-two-ways</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
          </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w">
         </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Ещё один тест проверяет, что вы вернём только самые короткие цепочки. Обмен с
четырьмя валютами (в данном случае <code class="language-plaintext highlighter-rouge">[:usd :yen :eur :rub]</code>) не попадёт в
результат:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">test-short-ways-only</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
          </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:rub</span><span class="p">]]</span><span class="w">
         </span><span class="p">(</span><span class="nf">exchanges</span><span class="w"> </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
                     </span><span class="p">[</span><span class="no">:yen</span><span class="w"> </span><span class="no">:eur</span><span class="p">]]</span><span class="w"> </span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>В терминах олимпиадного программирования можно сказать, что задача предлагает
отдельные рёбра графа. Требуется проверить, можно ли составить из рёбер
непрерывный маршрут от вершины А к B. Но в этой главе мы решим задачу на
зипперах и не будем использовать термины “граф” и “рёбра”. Мы не гарантируем,
что решение будет оптимальным, и возможно, алгоритм на графах справится
лучше. Однако надеемся, что пример ещё больше раскроет мощь зипперов.</p>

<p>Как вы помните, зипперы нужны для обхода деревьев, и условие задачи подходит для
этого. Представим, что на вершине дерева стоит валюта <code class="language-plaintext highlighter-rouge">from</code>, которую мы хотим
разменять. Пусть это будет доллар. Очевидно, что потомки этой валюты — все те,
что размениваются на доллар. Для этого выберем второй элемент из каждой пары,
где первый элемент равен <code class="language-plaintext highlighter-rouge">from</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">rules</span><span class="w">
  </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:tug</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="no">:usd</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">usd-children</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[[</span><span class="n">v1</span><span class="w"> </span><span class="n">v2</span><span class="p">]</span><span class="w"> </span><span class="n">rules</span><span class="w">
        </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">from</span><span class="p">)]</span><span class="w">
    </span><span class="n">v2</span><span class="p">))</span><span class="w">
</span><span class="c1">;; (:rub :lir)</span><span class="w">
</span></code></pre></div></div>

<p>Таким образом, потомки доллара – рубль и лира. Изобразим мнимое дерево и
обозначим уровни:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                  ┌───────┐
     1            │  usd  │
                  └───────┘
                      │
          ┌───────┐   │   ┌───────┐
     2    │  rub  │◀──┴──▶│  lir  │
          └───────┘       └───────┘
</code></pre></div></div>

<p>Для каждой валюты второго уровня найдём потомков по такому же правилу. Для
удобства напишем функцию <code class="language-plaintext highlighter-rouge">get-children</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-children</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[[</span><span class="n">v1</span><span class="w"> </span><span class="n">v2</span><span class="p">]</span><span class="w"> </span><span class="n">rules</span><span class="w">
        </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">value</span><span class="p">)]</span><span class="w">
    </span><span class="n">v2</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">get-children</span><span class="w"> </span><span class="no">:rub</span><span class="p">)</span><span class="w">
</span><span class="c1">;; (:eur :yen)</span><span class="w">
</span></code></pre></div></div>

<p>Новое дерево:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      ┌───────┐
    1                 │  usd  │
                      └───────┘
                          │
              ┌───────┐   │   ┌───────┐
    2         │  rub  │◀──┴──▶│  lir  │
              └───────┘       └───────┘
                  │               │
       ┌───────┐  │  ┌───────┐    │  ┌───────┐
    3  │  eur  │◀─┴─▶│  yen  │    └─▶│  tug  │
       └───────┘     └───────┘       └───────┘
</code></pre></div></div>

<p>Заметим, что это именно виртуальное дерево, о котором мы говорили недавно. У нас
нет этого дерева на руках – оно получается в процессе. Функция <code class="language-plaintext highlighter-rouge">make-children</code>
замкнута на исходных парах обмена. Это пример того, как обходить структуры
данных, которые получаем в полёте из других данных.</p>

<p>Структура дерева валют известна, и его можно обойти. Вопрос, до каких пор его
обходить? Очевидно, мы должны остановиться, как только встретим локацию, чей
узел равен валюте <code class="language-plaintext highlighter-rouge">to</code>. Пусть это будут йены. Это значит, мы соединили <code class="language-plaintext highlighter-rouge">from</code> и
<code class="language-plaintext highlighter-rouge">to</code> с помощью других валют. Обозначим решение на схеме:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      ┌───────┐
    1                 │  usd  │
                      └───────┘
                          │
              ┌───────┐   │   ┌ ─ ─ ─ ┐
    2         │  rub  │◀──┘
              └───────┘       └ ─ ─ ─ ┘
                  │
       ┌ ─ ─ ─ ┐  │  ┌───────┐       ┌ ─ ─ ─ ┐
    3             └─▶│  yen  │
       └ ─ ─ ─ ┘     └───────┘       └ ─ ─ ─ ┘

</code></pre></div></div>

<p>Чтобы получить цепочку обмена, локацию с <code class="language-plaintext highlighter-rouge">to</code> передают в функцию <code class="language-plaintext highlighter-rouge">zip/path</code>. Она вернёт
вектор всех родителей локации, не включая ее саму. Таким образом, путь к локации
и её узел образуют цепочку обмена.</p>

<p>На базе этих рассуждений напишем код. Подготовим зиппер:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">zip-val</span><span class="w">
  </span><span class="p">(</span><span class="nf">zip/zipper</span><span class="w"> </span><span class="nb">keyword?</span><span class="w">      </span><span class="c1">;; это валюта?</span><span class="w">
              </span><span class="n">get-children</span><span class="w">  </span><span class="c1">;; на что её можно разменять?</span><span class="w">
              </span><span class="n">nil</span><span class="w">
              </span><span class="n">from</span><span class="p">))</span><span class="w">        </span><span class="c1">;; исходная валюта</span><span class="w">
</span></code></pre></div></div>

<p>Ищем в зиппере локацию с целевой валютой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">loc-to?</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">zip/node</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">to</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc-to</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">zip-val</span><span class="w">
       </span><span class="n">iter-zip</span><span class="w">
       </span><span class="p">(</span><span class="nf">find-first</span><span class="w"> </span><span class="n">loc-to?</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Если нашли, то получим из неё цепочку обмена. Для этого к пути присоединим
значение <code class="language-plaintext highlighter-rouge">to</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/path</span><span class="w"> </span><span class="n">loc-to</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc-to</span><span class="p">))</span><span class="w">
</span><span class="c1">;; [:usd :rub :yen]</span><span class="w">
</span></code></pre></div></div>

<p>Основная задача решена. Но не обошлось без недостатков: для любых данных мы
получим только одну цепочку, даже если их несколько. Чтобы исправиться, ищем не
только первую локацию с валютой <code class="language-plaintext highlighter-rouge">to</code>, а их все с помощью <code class="language-plaintext highlighter-rouge">filter</code>.</p>

<p>Расширим исходные данные:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">rules</span><span class="w">
  </span><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:rub</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:eur</span><span class="w"> </span><span class="no">:lir</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="no">:lir</span><span class="w"> </span><span class="no">:tug</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="no">:usd</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="no">:yen</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>и найдём цепочки. Для этого заменим <code class="language-plaintext highlighter-rouge">find-first</code> на <code class="language-plaintext highlighter-rouge">filter</code>, который вернёт все
элементы, подходящие предикату, а не только первый.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">locs-to</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">zip-val</span><span class="w">
       </span><span class="n">iter-zip</span><span class="w">
       </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">loc-to?</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Для каждой найденной локации постоим путь:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">loc</span><span class="w"> </span><span class="n">locs-to</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/path</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc</span><span class="p">)))</span><span class="w">

</span><span class="p">([</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:eur</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:yen</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Теперь мы нашли цепочки всех длин, что может быть избыточно. По условию задачи
нам не нужен обмен из четырёх операций, если найден с двумя. Напишем функцию,
которая вернёт самые короткие списки из результата выше. Она группирует обмены
по длине, находит меньшую длину и выбирает из словаря.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-shortest-chains</span><span class="w">
  </span><span class="p">[</span><span class="n">chains</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">chains</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">count-&gt;chains</span><span class="w"> </span><span class="p">(</span><span class="nf">group-by</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="n">chains</span><span class="p">)</span><span class="w">
          </span><span class="n">min-count</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">min</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">count-&gt;chains</span><span class="p">))]</span><span class="w">
      </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">count-&gt;chains</span><span class="w"> </span><span class="n">min-count</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Для последнего результата получим два вектора по три валюты в каждом. Этот
случай покрывает последний тест <code class="language-plaintext highlighter-rouge">test-short-ways-only</code>, где длинные цепочки
отбрасываются:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:rub</span><span class="w"> </span><span class="no">:yen</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:usd</span><span class="w"> </span><span class="no">:lir</span><span class="w"> </span><span class="no">:yen</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>Из фрагментов кода соберите функцию <code class="language-plaintext highlighter-rouge">exchanges</code>. Добейтесь, чтобы проходили все
тесты. Добавьте в них больше случаев.</p>

<p>Кажется, что задача решена, однако её можно улучшить. Дело в том, что при особых
входных данных дерево станет бесконечным. Программа либо уйдёт в вечный цикл,
либо, если число шагов ограничить, не найдет решения. Не заглядывая вперед,
догадайтесь, что может быть тому причиной и как это исправить. На эти вопросы мы
ответим в следующем разделе.</p>

<p>(Продолжение следует)</p>

<h2 id="оглавление-1">Оглавление</h2>

<ul>
  <li><a href="/clj-zippers-1/">Зипперы (часть 1). Азы навигации</a></li>
  <li><a href="/clj-zippers-2/">Зипперы (часть 2). Автонавигация</a></li>
  <li><a href="/clj-zippers-3/">Зипперы (часть 3). XML-зипперы</a></li>
  <li><a href="/clj-zippers-4/">Зипперы (часть 4). Поиск в XML</a></li>
  <li><a href="/clj-zippers-5/">Зипперы (часть 5). Редактирование</a></li>
  <li><a href="/clj-zippers-6/">Зипперы (часть 6). Виртуальные деревья. Обмен валют</a></li>
  <li><a href="/clj-zippers-7/">Зипперы (часть 7). Обход в ширину. Улучшенный обмен валют</a></li>
  <li><a href="/clj-zippers-8/">Зипперы (часть 8). Заключение</a></li>
</ul>


  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-zippers-6/">
    <input required name="captcha" type="hidden" value="6 &#215; 7">

    <div class="block">
        <span class="comment-form-label"><small>6 &#215; 7 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
