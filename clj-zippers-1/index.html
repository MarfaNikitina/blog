<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Зипперы в Clojure (часть 1). Азы навигации</title>
  <meta name="description" content="Оглавление  Зипперы (часть 1). Азы навигации  Зипперы (часть 2). Автонавигация  Зипперы (часть 3). XML-зипперы  Зипперы (часть 4). Поиск в XML  Зипперы (част...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://grishaev.me/clj-zippers-1/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="https://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

  <script type="text/javascript" src="/assets/typo.js"></script>

</head>


  <body>
    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/interview/">Interview</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor hl" href="/clojure-in-prod/">Книга «Clojure на производстве»</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Зипперы в Clojure (часть 1). Азы навигации</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2020-07-17T00:00:00+00:00">
        Jul 17, 2020
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/zippers/" rel="tag">zippers</a>

</div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="оглавление">Оглавление</h2>

<ul>
  <li><a href="/clj-zippers-1/">Зипперы (часть 1). Азы навигации</a></li>
  <li><a href="/clj-zippers-2/">Зипперы (часть 2). Автонавигация</a></li>
  <li><a href="/clj-zippers-3/">Зипперы (часть 3). XML-зипперы</a></li>
  <li><a href="/clj-zippers-4/">Зипперы (часть 4). Поиск в XML</a></li>
  <li><a href="/clj-zippers-5/">Зипперы (часть 5). Редактирование</a></li>
  <li><a href="/clj-zippers-6/">Зипперы (часть 6). Виртуальные деревья. Обмен валют</a></li>
  <li><a href="/clj-zippers-7/">Зипперы (часть 7). Обход в ширину. Улучшенный обмен валют</a></li>
  <li><a href="/clj-zippers-8/">Зипперы (часть 8). Заключение</a></li>
</ul>

<p><em>В этой статье мы познакомимся с зипперами в языке Clojure. Это необычный способ
работы с коллекциями. С помощью зиппера можно обойти и изменить произвольные
данные, а также выполнить в них поиск. Зиппер — мощный инструмент, вложения в
который окупаются со временем. Однако он не так прост, как обычная итерация, и
требует подготовки.</em></p>

<p>Объясним зиппер простыми словами. Это обёртка, которая предлагает универсальные
действия над данными. Перечислим основные из них:</p>

<ul>
  <li>перемещение по вертикали: вниз к потомкам или вверх к родителю;</li>
  <li>перемещение по горизонтали: влево или вправо среди потомков;</li>
  <li>обход всей структуры данных;</li>
  <li>добавление, редактирование и удаление узлов.</li>
</ul>

<!-- more -->

<p>Это неполный список, и наиболее интересные решения мы раскроем по ходу
текста. Подчеркнём, что эти возможности доступны в работе с произвольными
данными, будь то комбинация векторов и словарей, XML или дерево. Из-за этого
зипперы становятся мощным инструментом. Разобраться с ними означает повысить
свои навыки и открыть новые двери.</p>

<p>Хорошая новость в том, что зипперы доступны в базовой поставке Clojure. Это не
сторонняя библиотека, которую нужно подключать. Зипперы легко добавить в проект,
не опасаясь проблем лицензии или новых зависимостей.</p>

<p>Зипперы в Clojure используют мощь неизменяемых коллекций. Технически зиппер —
это коллекция, которая хранит данные и позицию указателя в них. Всё вместе это
называется локацией (location). Шаг в любую сторону вернёт новую локацию подобно
тому, как функции assoc или update производят новые данные на базе старых.</p>

<p>Из текущей локации можно получить <em>узел</em> (ноду) — фрагмент данных, на который
ссылается указатель. На этом моменте путаются новички, поэтому уточним
различие. Локация — это исходные данные и положение в них. Передвижение по
локации порождает локацию. Из локации можно извлечь узел — данные, которые
встретились на этом участке.</p>

<p>Приведём пример с вектором <code class="language-plaintext highlighter-rouge">[1 2 3]</code>. Чтобы переместиться на <strong>двойку</strong>, нужно
обернуть данные в зиппер и выполнить команды <code class="language-plaintext highlighter-rouge">zip/down</code> и <code class="language-plaintext highlighter-rouge">zip/right</code>. С первым
шагом мы провалимся в вектор и окажемся на единице. Шаг вправо сдвинет нас на
двойку. Выразим это в коде: подключим пакет с псевдонимом <code class="language-plaintext highlighter-rouge">zip</code> и переместимся
по вектору:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.zip</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">zip</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/right</span><span class="w">
    </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 2</span><span class="w">
</span></code></pre></div></div>

<p>Цепочка из этих функций вернёт двойку, как и ожидалось. Последнее действие
<code class="language-plaintext highlighter-rouge">zip/node</code> выводит значение (узел) из текущей локации. Если убрать <code class="language-plaintext highlighter-rouge">zip/node</code>,
получим локацию, которая соответствует двойке. Выглядит она так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/right</span><span class="p">)</span><span class="w">

</span><span class="c1">;; [2 {:l [1], :pnodes [[1 2 3]], :ppath nil, :r (3)}]</span><span class="w">
</span></code></pre></div></div>

<p>Наверняка у вас возникли вопросы: откуда мы знаем путь к двойке, ведь она могла
быть в другом месте вектора? Что произойдет, если мы вышли за пределы коллекции?
Мы ответим на эти вопросы ниже. Пока что, если вам что-то непонятно, не впадайте
в панику: мы ещё не раз обсудим всё, что здесь происходит.</p>

<p>Итак, зиппер предлагает перемещение по данным. Несмотря на всю мощь, он не
знает, как это делать для конкретной коллекции, поэтому его нужно научить. Кроме
данных, зиппер требует ответы на два вопроса:</p>

<ul>
  <li>
    <p>Как узнать, является ли текущий элемент веткой (branch)? Так называют элемент,
из которого можно извлечь другие элементы.</p>
  </li>
  <li>
    <p>Если это ветка, то как извлечь из неё потомков?</p>
  </li>
</ul>

<p>Вот и всё, что нужно знать зипперу для навигации. Заметим, что для изменения
зиппера нужен ответ на ещё один вопрос — как присоединить потомков к
ветке. Однако сейчас мы рассматриваем только навигацию, и третий вопрос
подождёт.</p>

<p>В техническом плане ответы – это функции. Первая принимает узел и возвращает
истину или ложь. Если получили истину, зиппер вызовет вторую функцию. Она
принимает тот же узел, но на этот раз должна вернуть последовательность дочерних
узлов или nil, если их нет. В коде эти функции называют <code class="language-plaintext highlighter-rouge">branch?</code> и <code class="language-plaintext highlighter-rouge">children</code>.</p>

<p>Чтобы получить зиппер, нужно сообщить ему входные данные и две функции, которые
мы только что описали. До тех пор, пока мы только читаем зиппер, третья функция
может быть <code class="language-plaintext highlighter-rouge">nil</code>. Зипперы живут в пакете <code class="language-plaintext highlighter-rouge">clojure.zip</code>. Подключите его в
пространство:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">my.project</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.zip</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">zip</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>В свободное время исследуйте <a href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj">исходный код</a> этого модуля. Он занимает
всего 280 строк!</p>

<p>Функция <code class="language-plaintext highlighter-rouge">zip/zipper</code> порождает зиппер из исходных данных и функций. Это
центральная точка модуля, его строительный материал. Для частых случаев модуль
предлагает уже готовые зипперы, которые ожидают только данные. Хорошим примером
служит <code class="language-plaintext highlighter-rouge">vector-zip</code> для вложенных векторов. Приведём его код в сокращении:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">vector-zip</span><span class="w">
  </span><span class="p">[</span><span class="nb">root</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="nb">vector?</span><span class="w">
          </span><span class="nb">seq</span><span class="w">
          </span><span class="n">...</span><span class="w">
          </span><span class="nb">root</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Третий параметр мы заменили на многоточие. Это функция, которая присоединяет к
ветке дочерные узлы при изменении (пока что обходим этот вопрос стороной). Если
передать в <code class="language-plaintext highlighter-rouge">vector-zip</code> вектор <code class="language-plaintext highlighter-rouge">[1 2 3]</code>, произойдёт следующее.</p>

<p>Зиппер обернёт вектор и выставит указатель на него самого. Из начального
положения можно проследовать только вниз, потому что на вершине у зиппера нет
родителя (вверх) и соседей (влево и вправо). При смещении <strong>вниз</strong> зиппер
сначала проверит, что текущий узел — ветка. Сработает выражение <code class="language-plaintext highlighter-rouge">(vector? [1 2
3])</code>, что вернёт истину. В этом случае зиппер выполнит <code class="language-plaintext highlighter-rouge">(seq [1 2 3])</code>, чтобы
получить потомков. Ими станет последовательность <code class="language-plaintext highlighter-rouge">(1 2 3)</code>. Как только потомки
найдены, зиппер установит указатель на крайний левый потомок – единицу.</p>

<p>Покажем это на схеме. Начальная позиция, указатель на исходном векторе:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌───────┐
                │  nil  │
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃  [1 2 3]  ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   1   │
                └───────┘
</code></pre></div></div>

<p>Шаг вниз, указатель на единице:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌───────┐
                │[1 2 3]│
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃     1     ┃───▶│   2   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>Шаг вправо, указатель на двойке:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌───────┐
                │[1 2 3]│
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>Итак, мы находимся на двойке и можем двигаться дальше по горизонтали. Новый шаг
вправо сдвинет нас на тройку, обратно влево – на единицу. Вот как это выглядит
в коде:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc2</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
      </span><span class="n">zip/vector-zip</span><span class="w">
      </span><span class="n">zip/down</span><span class="w">
      </span><span class="n">zip/right</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc2</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 2</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc2</span><span class="w"> </span><span class="n">zip/right</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 3</span><span class="w">

</span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc2</span><span class="w"> </span><span class="n">zip/left</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; 1</span><span class="w">
</span></code></pre></div></div>

<p>При попытке сдвинуться вниз зиппер выполнит предикат <code class="language-plaintext highlighter-rouge">(vector? 2)</code>. Результат
будет ложью, что означает, что текущий элемент не ветка, и движение вниз
запрещено.</p>

<p>При передвижении нужно учитывать следующее. Каждый шаг порождает новую локацию,
не изменяя старую. Если вы сохранили очередную локацию в переменную, дальнейшие
вызовы <code class="language-plaintext highlighter-rouge">zip/right</code>, <code class="language-plaintext highlighter-rouge">zip/down</code> и другие никак её не изменят. Выше мы объявили
переменную <code class="language-plaintext highlighter-rouge">loc2</code>, которая указывает на двойку. Можно оттолкнуться от неё, чтобы
получить исходный вектор:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">loc2</span><span class="w"> </span><span class="n">zip/up</span><span class="w"> </span><span class="n">zip/node</span><span class="p">)</span><span class="w">
</span><span class="c1">;; [1 2 3]</span><span class="w">
</span></code></pre></div></div>

<p>При ручном перемещении велики шансы выйти за пределы коллекции. Шаг в никуда
вернёт <code class="language-plaintext highlighter-rouge">nil</code> вместо локации:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/left</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre></div></div>

<p>Это сигнал, что вы идёте по неверному маршруту. Проблема в том, что из <code class="language-plaintext highlighter-rouge">nil</code>
нельзя вернуться на прежнее место. <code class="language-plaintext highlighter-rouge">Nil</code> означает пустую локацию, и в ней нет
ссылки на прежний шаг. Для пустой локации функции <code class="language-plaintext highlighter-rouge">zip/up</code>, <code class="language-plaintext highlighter-rouge">zip/right</code> и другие
тоже вернут <code class="language-plaintext highlighter-rouge">nil</code>. Если не учесть это в цикле, вы будете топтаться на месте.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/left</span><span class="w">
    </span><span class="n">zip/left</span><span class="w">
    </span><span class="n">zip/left</span><span class="w">
    </span><span class="n">zip/left</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>К исключению относится функция <code class="language-plaintext highlighter-rouge">zip/down</code>: при попытке спуститься из <code class="language-plaintext highlighter-rouge">nil</code> вы
получите ошибку <code class="language-plaintext highlighter-rouge">NullPointerException</code>. Это недочёт, который забыли исправить в
коде зиппера.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="w">
    </span><span class="n">zip/left</span><span class="w">
    </span><span class="n">zip/down</span><span class="p">)</span><span class="w">

</span><span class="c1">;; Execution error (NullPointerException)...</span><span class="w">
</span></code></pre></div></div>

<p>Рассмотрим случай с более сложным вектором. Один из его потомков — другой
вектор: <code class="language-plaintext highlighter-rouge">[1 [2 3] 4]</code>. Чтобы переместить указатель на <strong>тройку</strong>, выполним шаги
“вниз”, “вправо”, “вниз”, “вправо”. Сохраним локацию в переменную:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">loc3</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w">
      </span><span class="n">zip/vector-zip</span><span class="w">
      </span><span class="n">zip/down</span><span class="w">
      </span><span class="n">zip/right</span><span class="w">
      </span><span class="n">zip/down</span><span class="w">
      </span><span class="n">zip/right</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">zip/node</span><span class="w"> </span><span class="n">loc3</span><span class="p">)</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span></code></pre></div></div>

<p>Рисунки ниже показывают, что происходит на каждом шаге. Исходная позиция:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌───────┐
                │  nil  │
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃[1 [2 3] 4]┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   1   │
                └───────┘
</code></pre></div></div>

<p>Шаг вниз:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃     1     ┃───▶│ [2 3] │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>Вправо:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃   [2 3]   ┃───▶│   4   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   2   │
                └───────┘
</code></pre></div></div>

<p>Вниз:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │   [2 3]   │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>Вправо. Мы у цели:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │   [2 3]   │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   2   │◀───┃     3     ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>Чтобы перейти на <strong>четвёрку</strong> из текущей позиции, сначала поднимемся
вверх. Указатель сдвинется на вектор [2 3]. Теперь мы находимся среди потомков
исходного вектора и можем перемещаться по горизонтали. Сделаем шаг вправо и
окажемся на цифре 4.</p>

<p>То же самое графически. Текущая локация (тройка):</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │   [2 3]   │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   2   │◀───┃     3     ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>Шаг вверх:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃   [2 3]   ┃───▶│   4   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   2   │
                └───────┘
</code></pre></div></div>

<p>Шаг вправо:</p>

<div class="language-plaintext asciichart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │ [2 3] │◀───┃     4     ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
</code></pre></div></div>

<p>Исходный вектор может быть любой вложенности. Ради интереса замените 3 на ещё
один вектор и спуститесь в него.</p>

<p>Что случится, если передать в <code class="language-plaintext highlighter-rouge">vector-zip</code> что-то отличное от вектора?
Предположим, nil, строку или число. Перед тем, как двигаться, зиппер проверяет,
подходит ли узел на роль ветки и можно ли извлечь из него потомков. Для
<code class="language-plaintext highlighter-rouge">vector-zip</code> проверка выполняется с помощью функции <code class="language-plaintext highlighter-rouge">vector?</code>, которая вернет
nil для всех отличных от вектора значений. В результате получим локацию, из
которой нельзя шагнуть никуда: ни вниз, ни в стороны. Это тупиковый случай, и
его нужно избегать.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="s">"test"</span><span class="w">
    </span><span class="n">zip/vector-zip</span><span class="w">
    </span><span class="n">zip/down</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre></div></div>

<p>Модуль <code class="language-plaintext highlighter-rouge">clojure.zip</code> предлагает и другие встроенные зипперы. Особенно интересен
xml-zip для навигации по XML-дереву. Мы обсудим его отдельно, когда читатель
познакомится с другими свойствами зипперов.</p>

<p>(Продолжение следует)</p>

<h2 id="оглавление-1">Оглавление</h2>

<ul>
  <li><a href="/clj-zippers-1/">Зипперы (часть 1). Азы навигации</a></li>
  <li><a href="/clj-zippers-2/">Зипперы (часть 2). Автонавигация</a></li>
  <li><a href="/clj-zippers-3/">Зипперы (часть 3). XML-зипперы</a></li>
  <li><a href="/clj-zippers-4/">Зипперы (часть 4). Поиск в XML</a></li>
  <li><a href="/clj-zippers-5/">Зипперы (часть 5). Редактирование</a></li>
  <li><a href="/clj-zippers-6/">Зипперы (часть 6). Виртуальные деревья. Обмен валют</a></li>
  <li><a href="/clj-zippers-7/">Зипперы (часть 7). Обход в ширину. Улучшенный обмен валют</a></li>
  <li><a href="/clj-zippers-8/">Зипперы (часть 8). Заключение</a></li>
</ul>


  </div>

</article>

<center>
    <p>
        <small>Нашли ошибку? Выделите мышкой и нажмите Ctrl/&#8984;+Enter</small>
    </p>
</center>






<center>Комментариев пока нет</center>









<form id="comment-form" method="POST" action="https://functions.yandexcloud.net/d4ehfuf08fjfjr59ivnf">

    <div class="block">
        <p class="comment-form-label"><small>Your name</small></p>
        <input required id="comment-form-author" name="author" type="text">
    </div>

    <div class="block">
        <p class="comment-form-label"><small>Comment (markdown syntax)</small></p>
        <textarea required id="comment-form-comment" name="comment"></textarea>
    </div>

    <input required name="path" type="hidden" value="/clj-zippers-1/">
    <input required name="captcha" type="hidden" value="3 &#215; 8">

    <div class="block">
        <span class="comment-form-label"><small>3 &#215; 8 = </small></span>
        <input required id="comment-form-solution" name="solution" type="text">
    </div>

    <div class="block">
        <button id="comment-form-send" type="submit">Send</button>
    </div>

</form>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
            <li><a href="https://github.com/igrishaev">GitHub</a></li>
            <li><a href="tg://resolve?domain=igrishaev_blog">Telegram</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
