<!DOCTYPE html>
<html lang="ru">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Введение в веб-разработку на Clojure. Часть I</title>
  <meta name="description" content="(This is my attempt to compose a book about Clojure. I decided to start with aweb development section to see how far I could go. It’s in Russian because here...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="http://grishaev.me/clj-book-web-1/">
  <link rel="alternate" type="application/rss+xml" title="Ivan Grishaev's blog" href="http://grishaev.me/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/static/favicons/favicon.ico">

</head>


  <body>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-33533163-2', 'auto');
    ga('send', 'pageview');

</script>

    <header class="site-header">

    <div class="wrapper flex-container">

        <div>
            <a href="/">
                <img src="/assets/static/photo-round-small.png" alt="Ivan Grishaev">
            </a>
        </div>

        <div class="flex-container-vert" style="margin-left: 15px; width: 80%">

            <div class="flex-container full-width">
                <p style="margin-bottom: 5px">Ivan Grishaev's blog</p>
                <div class="flex-huge"></div>
                <div >
<form id="search-form"
      target="_blank"
      style="display: inline"
      method="get"
      action="https://www.google.com/search">

    <input name="sitesearch"
           value="grishaev.me"
           type="hidden">

    <input type="text"
           required="required"
           name="q"
           placeholder="Google search..."
           autocomplete="off">

    <button style="border: none; background-color: transparent; cursor: pointer;"
            type="submit">&#x1f50d;</button>

</form>
</div>
            </div>

            <p><small>Writing on programming, education, books and negotiations.
</small></p>

            <div class="flex-container">
                <a class="menu-item" href="/">Home</a>
                <a class="menu-item" href="/about/">About</a>
                <a class="menu-item" href="/bookshelf/">Bookshelf</a>
                <a class="menu-item" href="/feed.xml">RSS</a>
            </div>

            <div class="flex-container">
                <a class="menu-item minor" href="/tag/clojure/">Clojure</a>
                <a class="menu-item minor" href="/tag/emacs/">Emacs</a>
                <a class="menu-item minor" href="/tag/python/">Python</a>
                <a class="menu-item minor" href="/tag/programming/">Programming</a>
                <a class="menu-item minor" href="/video/">Video</a>
            </div>

        </div>
    </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">

    <h1 class="post-title" itemprop="name headline">Введение в веб-разработку на Clojure. Часть I</h1>

    
<div class="post-meta">

    <time class="post-time"
          datetime="2019-03-20T00:00:00+00:00">
        Mar 20, 2019
    </time>

    <a href="/tag/clojure/" rel="tag">clojure</a>, <a href="/tag/book/" rel="tag">book</a>, <a href="/tag/web/" rel="tag">web</a>, <a href="/tag/programming/" rel="tag">programming</a>

</div>

    <script src="https://yastatic.net/es5-shims/0.0.2/es5-shims.min.js"></script>
<script src="https://yastatic.net/share2/share.js"></script>
<div class="ya-share2" data-services="twitter,telegram,facebook,vkontakte,lj,evernote,linkedin,reddit" data-limit="4"></div>


  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>(This is my attempt to compose a book about Clojure. I decided to start with a
web development section to see how far I could go. It’s in Russian because here
Clojure isn’t popular and its popularity across developers is low. I hope I’ll
translate this in English one day.)</em></p>

<h2>

    Содержание

</h2>

<ul id="toc-item-clj-book-web">
  <li><a href="#Основы-http" id="toc-item-clj-book-web-Основы-http">Основы HTTP</a></li>
  <li><a href="#Возвращаясь-к-clojure" id="toc-item-clj-book-web-Возвращаясь-к-clojure">Возвращаясь к Clojure</a></li>
  <li><a href="#Подробней-о-запросах-и-ответах" id="toc-item-clj-book-web-Подробней-о-запросах-и-ответах">Подробней о запросах и ответах</a>    <ul>
      <li><a href="#Структура-ответа" id="toc-item-clj-book-web-Структура-ответа">Структура ответа</a></li>
    </ul>
  </li>
  <li><a href="#Маршрутизация" id="toc-item-clj-book-web-Маршрутизация">Маршрутизация</a>    <ul>
      <li><a href="#Наивный-подход" id="toc-item-clj-book-web-Наивный-подход">Наивный подход</a></li>
      <li><a href="#compojure" id="toc-item-clj-book-web-compojure">Compojure</a></li>
      <li><a href="#Продвинутые-возможности" id="toc-item-clj-book-web-Продвинутые-возможности">Продвинутые возможности</a></li>
      <li><a href="#Роутинг-с-bidi" id="toc-item-clj-book-web-Роутинг-с-bidi">Роутинг с Bidi</a></li>
      <li><a href="#Выбор-между-compojure-и-bidi" id="toc-item-clj-book-web-Выбор-между-compojure-и-bidi">Выбор между Compojure и Bidi</a></li>
    </ul>
  </li>
  <li><a href="#middleware" id="toc-item-clj-book-web-middleware">Middleware</a>    <ul>
      <li><a href="#Параметры-запроса" id="toc-item-clj-book-web-Параметры-запроса">Параметры запроса</a></li>
      <li><a href="#cookie" id="toc-item-clj-book-web-cookie">Cookie</a></li>
      <li><a href="#Сессии" id="toc-item-clj-book-web-Сессии">Сессии</a></li>
      <li><a href="#json" id="toc-item-clj-book-web-json">JSON</a></li>
      <li><a href="#Собственные-middleware" id="toc-item-clj-book-web-Собственные-middleware">Собственные middleware</a>        <ul>
          <li><a href="#wrap-headers-kw" id="toc-item-clj-book-web-wrap-headers-kw">wrap-headers-kw</a></li>
          <li><a href="#wrap-request-id" id="toc-item-clj-book-web-wrap-request-id">wrap-request-id</a></li>
          <li><a href="#wrap-current-user" id="toc-item-clj-book-web-wrap-current-user">wrap-current-user</a></li>
        </ul>
      </li>
      <li><a href="#Прерывание-стека" id="toc-item-clj-book-web-Прерывание-стека">Прерывание стека</a></li>
      <li><a href="#middleware-вне-стека" id="toc-item-clj-book-web-middleware-вне-стека">Middleware вне стека</a></li>
      <li><a href="#Все-вместе" id="toc-item-clj-book-web-Все-вместе">Все вместе</a></li>
    </ul>
  </li>
</ul>

<p>В этой главе мы рассмотрим азы разработки на Clojure под
веб-платформу. Поговорим о том, как устроен протокол HTTP и как передавать по
нему данные. Рассмотрим, какие абстракции использует Clojure над протоколом,
чтобы сделать разработку быстрой и удобной.</p>

<p>Каждый год компания Cognitect <a href="http://blog.cognitect.com/blog/2017/1/31/clojure-2018-results">опрашивает</a>
Clojure-разработчиков. Среди прочих вопросов встречается о том, в какой области
вы работаете? В 2010 году веб-разработкой занимались 50% опрошенных, то есть
каждый второй. К 2018 году эта цифра выросла до 82%. Это уже четыре человека из
пяти.</p>

<p>Развитие веба не связано напрямую с Clojure. Похожую динамику показывают
ежегодные опросы <a href="https://insights.stackoverflow.com/survey/2018/">StackOverflow</a>. Согласно им, все больше разработчиков
переходит из смежных областей в веб.</p>

<p>Справедливо утверждать, что если вы найдете работу на Clojure, то скорее всего
это будет веб-приложение. Речь необязательно идет о сайте компании. Иногда такие
сайты даже бывают статичными, то есть состоят из набора HTML-файлов. Но
веб-приложение — это не только текст с картинками. В общем значении это передача
и обработка данных по протоколу HTTP.</p>

<p>Напомним, протокол изначально предназначен для передачи HTML-разметки. Но
удивительным образом подошел для обмена данными. Для этого даже не пришлось
менять стандарт. Причина кроется в его изящном дизайне, простоте и гибкости.</p>

<p>Прежде чем перейти к Clojure, давайте освежим в памяти устройство протокола. Из
каких частей он состоит и по каким правилам сервер его обрабатывает. Это важно,
потому что языки и фреймворки меняются, а протокол нет.</p>

<!-- more -->

<h2 id="Основы-http">Основы HTTP</h2>

<p>HTTP это протокол, который работает поверх TCP/IP. Протокол в широком смысле —
это соглашение о том, в каком порядке передавать данные. Протоколы обычно
зафиксированы в официальных документах. Для HTTP такой документ называется <a href="https://tools.ietf.org/html/rfc2616">RFC
2616</a>. Разработчики браузеров и фреймворков должны сверяться с этим
документом во время работы.</p>

<p>HTTP удобен тем, что это текст. Разработчику не нужно декодировать байты, чтобы
понять семантику происходящего. Протокол не исключает передачу бинарных данных,
но основные его части все же представлены текстом.</p>

<p>Различают HTTP-запрос и ответ. Оба состоят из трех частей: первая строка,
заголовки и тело.</p>

<p>Первая (или стартовая) строка содержит самую важную информацию о запросе или
ответе. Формат строки различается для запроса и ответа. Для запроса это метод,
путь и версия, для ответа — статус, сообщение и версия.</p>

<p>Заголовки — это пары ключ-значение. В современных фреймворках они, как правило,
выражены словарем. Заголовки содержат дополнительные сведения о запросе или
ответе. Например, заголовок Content-Type сообщает, как следует трактовать тело
запроса. Был ли это XML- или JSON-документ? Программа проверяет заголовок и
читает содержимое должным образом.</p>

<p>После заголовков следует тело. Телом может быть что угодно — текст, данные в
виде “поле=значение”, JSON-документ, картинка, фильм, электронное
письмо. Стандарт предусматривает смешанный тип, т.н. multipart-encoding. Тело
такого запроса раздроблено на ячейки, в каждом из которых живет свое
содержимое. Например, текст, картинка, снова текст, двоичный файл.</p>

<p>Несколько примеров HTTP-запросов и ответов. Именно в таком виде они передаются
по сети. Это запрос к главной странице Google, поисковой терм — сlojure:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/search?q=clojure</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">google.com</span>
<span class="na">Accept-Language</span><span class="p">:</span> <span class="s">en-us</span>
<span class="na">Accept-Encoding</span><span class="p">:</span> <span class="s">gzip, deflate</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)</span>
<span class="s">(blank line)</span>
</code></pre></div></div>

<p>Пример POST-запроса с передачей JSON-документа:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">POST</span> <span class="nn">/api/users/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">example.com</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/json</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)</span>

<span class="p">{</span><span class="w">
  </span><span class="s2">"username"</span><span class="p">:</span><span class="w"> </span><span class="s2">"John"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"city"</span><span class="p">:</span><span class="w"> </span><span class="s2">"NY"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Ответ на такой запрос:</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="na">Date</span><span class="p">:</span> <span class="s">Tue, 19 Mar 2019 15:57:11 GMT</span>
<span class="na">Server</span><span class="p">:</span> <span class="s">Nginx</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">close</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/json</span>

<span class="p">{</span><span class="w">
  </span><span class="s2">"code"</span><span class="p">:</span><span class="w"> </span><span class="s2">"CREATED"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"A user has been created successfully"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Легко увидеть, как изящно устроен протокол. Данные в нем располагаются по
убыванию важности. Прочитав только первую строку запроса, клиент и сервер готовы
принять решение о том, что делать дальше.</p>

<p>Рассмотрим сценарий: в запросе указаны метод и путь <code class="highlighter-rouge">GET /about</code>, но такой
страницы не существует. Сервер может проверить это заранее, например, сверив
путь с конфигурацией маршрутов. Когда маршрута нет, сервер вернет ответ со
статусом 404. Не придется читать тело запроса, что существенно ускорит работу
сервера.</p>

<p>Получив ответ, клиент прочитает статус 404 из первой строки. Такой ответ
трактуется как ошибочный. Логика клиента может быть такова, что в случае ошибки
читать тело ответа не нужно. Это облегчит работу клиента.</p>

<p>Чтение и разбор содержимого это дорогая операция. Современные фреймворки
пытаются исключить случаи, когда чтение происходит зря. Например, по заголовку
<code class="highlighter-rouge">Content-Type</code> мы определяем, стоит ли читать тело. Наше приложение работает
только с JSON, поэтому для значения <code class="highlighter-rouge">text/xml</code> вернем ошибку. Аналогично с
заголовком <code class="highlighter-rouge">Content-Length</code>, где содержится длина тела в байтах. Если значение
больше заданного лимита, сервер отклонит запрос до чтения тела.</p>

<p>Центральные параметры запроса это метод и путь. Путь указывает на определенный
ресурс на сервере. Иногда сервер трактует путь как файл относительно заданной
директории. Например, <code class="highlighter-rouge">/images/map.jpg</code> означает вернуть такой файл из
директории <code class="highlighter-rouge">/var/www/static</code>. Но чаще всего приложение обрабатывает путь
согласно внутренней логике. Ответом приложения может быть не только файл, но и
js-скрипт, HTML-разметка или JSON-документ.</p>

<p>Метод запроса означает действие, которые мы намерены выполнить над
ресурсом. Основные методы это GET, POST, PUT и DELETE. Их семантика в том же
порядке — прочитать, создать, обновить, удалить ресурс. Так, запрос <code class="highlighter-rouge">POST
/users/</code> означает создать пользователя, а <code class="highlighter-rouge">GET /users/1</code> — чтение пользователя
под номером 1.</p>

<p>Главный параметр ответа это статус — целое положительное число. Статусы
группируют по старшему разряду. Значения с 200 до 299 (или 2хх) считаются
положительными. Они означают, что сервер успешно обработал запрос.</p>

<p>Значения в группе 3хх связаны с перенаправлением на другую страницу. Как
правило, в заголовке Location сервер сообщает путь, по которому следует
обратиться. Современные браузеры и HTTP-клиенты достаточно умны, чтобы
автоматически послать второй запрос по новому адресу. Так, при запросе страницы
<code class="highlighter-rouge">http://yandex.ru</code> вы получите пустой документ с заголовком <code class="highlighter-rouge">Location:
https://yandex.ru</code> (безопасное соединение). Но браузер переключит страницу сам.</p>

<p>Статусы из группы 4хх означают ошибку на стороне клиента. Чаще всего это 404 —
страница не найдена. На ошибочные данные сервер отвечает 400 — Bad
request. Когда нет прав на просмотр документа, клиент получит код 403.</p>

<p>Статусы из группы 5хх сигнализируют об ошибке на стороне сервера или полной его
недоступности. Это деление на ноль, недоступность базы данных, недостаток места
на диске.</p>

<p>Принято считать, что ответ со статусом вне диапазона 2хх означает
ошибку. Большинство HTTP-клиентов запрограммированы на выброс исключения в таких
случаях. Строго говоря, это верно только на высоком, абстрактном уровне. С точки
зрения протокола ответ 404 Not Found такой же правильный, как и 200 OK.</p>

<p>Дополнительные операции над ресурсом используют другие, более редкие
методы. Например, HEAD — получить только краткие сведения об объекте. Сервис
Amazon S3 в ответ на HEAD-запрос отдает только статус и заголовки. В них указаны
тип файла и размер, контрольная сумма, дата последнего изменения. В данном
случае HEAD-запрос предпочтительней GET. Метаданные могут храниться в особом
хранилище отдельно от файла. Доступ к такому хранилищу обычно быстрее, чем к
файлу на диске.</p>

<p>Подход “метод-ресурс” со временем вырос в то, что сегодня называется
<a href="https://www.restapitutorial.com/">REST</a>. Последователи REST выделяют бизнес-сущности и CRUD-операции
над ними (Create, Read, Update, Delete). Считается хорошим подход, когда
сущность определяется через путь, например <code class="highlighter-rouge">/users/1</code>, а операция —
методом. Если это создание или изменение сущности, данные читаются из тела,
обычно JSON-документа. Мы не будем задерживаться на REST, потому что это всего
лишь свод рекомендаций, не идеальный и не единственный.</p>

<p>Отметим, что HTTP не предусматривает строгое соблюдение этих
рекомендаций. Разработчик вправе обрабатывать запросы и ответы так, как удобно в
данном случае. Например, принимать только POST-запросы с данными в теле. Или
только GET с параметрами из строки запроса. Верную стратегию определяют бизнес,
инструменты или потребители сервиса.</p>

<h2 id="Возвращаясь-к-clojure">Возвращаясь к Clojure</h2>

<p>Современные фреймворки строят абстракции над HTTP-протоколом. Разработчику не
требуется читать данные из сокета и выполнять разбор запроса, ровно как и писать
в сокет байты ответа. Эту задачу берет на себя фреймворк и сервер.</p>

<p>Взамен разработчик получает набор классов, чтобы с их помощью выразить
бизнес-логику приложения. Типичный веб-проект на Python или Java это комбинация
нескольких классов. Как правило, это <code class="highlighter-rouge">Application</code> — главная сущность
проекта. Класс <code class="highlighter-rouge">Router</code> определяет, на какой обработчик переключить входящий
запрос — <code class="highlighter-rouge">Request</code>. Обработчик — это класс <code class="highlighter-rouge">Handler</code> с методами <code class="highlighter-rouge">.onGet</code>,
<code class="highlighter-rouge">.onPost</code> и тд. Ожидается, что он вернет экземпляр класса <code class="highlighter-rouge">Response</code>.</p>

<p>По такому принципу устроены все промышленные веб-фреймворки: Django, Rails,
Symfony. Названия классов и их композиция различаются, но суть остается
прежней. Это приложение, маршрутизатор, обработчик, запрос и ответ. Проблема в
том, что каждый фремворк моделирует собственные классы, которые несовместимы
между собой в рамках языка.</p>

<p>Рассмотрим язык Python и фреймворки Django и Flask. Оба следуют той же
структуре. Так, запрос в Django представлен классом <code class="highlighter-rouge">django.http.HttpRequest</code>, а
во Flask — <code class="highlighter-rouge">flask.Request</code>. Даже беглого взгляда достаточно, чтобы увидеть,
насколько они отличаются. У классов разные методы и поля. То, что есть в первом
классе, отсутствует во втором. Использовать <code class="highlighter-rouge">flask.Request</code> в проекте на Django
не представляется возможным.</p>

<p>Это приводит к тому, что проект увязает в архитектуре фреймворка. Переезд на
другой фремворк обходится с трудом. Хорошие практики предписывают разделять
проект на слои. Слой транспорта отвечает за ввод и вывод данных по протоколу
HTTP. Слой логики исполняет внутренний код, ничего не зная о HTTP. Согласно
такому принципу, логика не зависит от транспорта, и последний может быть изменен
в любой момент. Но на практике это справедливо не всегда. Порой мы вынуждены
сделать слишком много за короткое время. Нам не дают исправить поспешные
решения, и плохой код остается в проекте навсегда.</p>

<p>В Clojure другой подход.</p>

<p>Разработчик <a href="https://www.booleanknot.com/">Джеймс Ривз</a> (James Reeves) известен своим вкладом в
экосистему Clojure. Он разработал 60 библиотек для самых разных задач. Нет
такого проекта на Clojure, который бы не использовал его наработки.</p>

<p>Заслуга Джеймса в том, что он стандартизировал веб-разработку для Clojure на
заре этого языка. Вместо того, чтобы писать фремворк под сиюминутные нужды, он
придумал, как сделать удобно всем.</p>

<p>Джеймс предложил несколько простых идей. Первая — если приложение принимает
запрос и возвращает ответ, то резонно выразить его функцией. Действительно,
приложения бывают сколь угодно сложным. Они полагаются на сторонние сервисы,
машинное обучение, учитывают сотню фактов о пользователе. Но они принимают
запрос и возвращают ответ, поэтому на абстрактном уровне это функция.</p>

<p>Скептики могут заметить, что мысль не нова. Действительно, в том же Django
обработчик запроса может быть не классом, а функцией. Разница в том, что
отдельный обработчик — это еще не приложение. Ему не хватает маршрутизатора,
middleware и других абстракций. Поэтому в мире Django или Flask выразить
обработчик функцией — всего лишь приятная возможность фреймворка.</p>

<p>Но Clojure устроена так, что маршрутизатор — это тоже функция, которая принимает
запрос, определяет нужный обработчик и возвращает ответ. Middleware это тоже
функция, которая принимает функцию-обработчик и возвращают новый обработчик с
дополненной логикой. Каждую тяжелую абстракцию (классы <code class="highlighter-rouge">Application</code>, <code class="highlighter-rouge">Router</code>,
<code class="highlighter-rouge">Handler</code>) в мире Clojure принято заменять функцией. Это удобно, потому что в
отличии от классов функции компонуются.</p>

<p>Вторая идея Джеймса в том, чтобы зафиксировать структуру запроса и
ответа. Должны быть документы (не код, а именно документы), где описаны поля
этих структур и их семантика. Это напоминает спецификацию протокола HTTP.</p>

<p>Спецификация упрощает разработку и переносимость кода. Два веб-проекта на
Clojure обязаны принимать и отдавать одинаковые структуры данных. Разработчик
очередного фреймворка должен учитывать спецификацию. Если фреймворк следует
стандартам, проще привлечь на свою сторону сообщество.</p>

<p>Описанные выше идеи выражены в проекте Ring. Сегодня это стандарт веб-разработки
в Clojure. Репозиторий содержит спецификацию запроса и ответа и базовый код для
обработки этих структур. Плюс основные middleware, запуск Jetty-сервера и
документация. Удивительно, как мало кода понадобилось проекту, чтобы попасть на
компьютер каждому Clojure-разработчику.</p>

<p>Со временем появился термин “Ring-совместимость”. Его придерживаются все
современные Clojure-фреймворки. Типичное Ring-приложение запускается на многих
платформах: Jetty, Netty, Immutant и др. без изменений в коде.</p>

<p>Библиотека Ring разбита на отдельные части, чтобы установить только
необходимое. Перечислим компоненты, что будем использовать ниже:</p>

<ul>
  <li><code class="highlighter-rouge">ring-core</code> — базовая функциональность: параметры, разбор тела, куки, сессии,
и тд;</li>
  <li><code class="highlighter-rouge">ring-jetty-adapter</code> — запуск полноценного веб-сервера из функции-приложения.</li>
</ul>

<p>Свое первое веб-приложение вы напишете даже без библиотеки. Вот оно:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">uri</span><span class="w"> </span><span class="n">request-method</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="s">"Content-Type"</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"You requested %s %s"</span><span class="w">
                   </span><span class="p">(</span><span class="nb">name</span><span class="w"> </span><span class="n">request-method</span><span class="p">)</span><span class="w">
                   </span><span class="n">uri</span><span class="p">)}))</span><span class="w">
</span></code></pre></div></div>

<p>Приложение извлекает путь и метод из запроса и формирует ответ. Его статус
положительный — 200. Мы выставили один заголовок с типом документа “простой
текст”. Поле <code class="highlighter-rouge">:body</code> содержит строку, которую мы построили функцией format.</p>

<p>Поскольку app это функция, вызовем ее с различными запросами:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">app</span><span class="w"> </span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:get</span><span class="w"> </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/index.html"</span><span class="p">})</span><span class="w">
</span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="n">,</span><span class="w">
 </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="s">"Content-Type"</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="n">,</span><span class="w">
 </span><span class="no">:body</span><span class="w"> </span><span class="s">"You requested get /index.html"</span><span class="p">}</span><span class="w">

</span><span class="p">(</span><span class="nf">app</span><span class="w"> </span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:post</span><span class="w"> </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/users"</span><span class="p">})</span><span class="w">
</span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="n">,</span><span class="w">
 </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="s">"Content-Type"</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="n">,</span><span class="w">
 </span><span class="no">:body</span><span class="w"> </span><span class="s">"You requested post /users"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Работает. Но пока что это структуры данных, и не ясно, что будет в
браузере. Запустим приложение как HTTP-сервер.</p>

<p>Сервер это отдельная сущность. Он связывает структуры данных с сетевым
вводом-выводом. Сервер принимает приложение, некоторые дополнительные параметры
и запускает в фоне сложный процесс. Он слушает указанный порт и считывает
запросы клиента. Из бинарных данных сервер восстанавливает структуру
запроса. Затем, в отдельном треде, вызывает функцию-проложение с этим
запросом. Результатом будет структура ответа. Сервер преобразует ответ в
байтовый поток и записывает в удаленный порт клиента. Этот цикл повторяется для
каждого запроса.</p>

<p>Добавим в проект зависимости:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ring/ring-core</span><span class="w"> </span><span class="s">"1.7.1"</span><span class="p">]</span><span class="w">
</span><span class="p">[</span><span class="n">ring-jetty-adapter</span><span class="w"> </span><span class="s">"1.7.1"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Пример запуска сервера:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.adapter.jetty</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">run-jetty</span><span class="p">]])</span><span class="w">
</span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w"> </span><span class="no">:join?</span><span class="w"> </span><span class="n">true</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Здесь происходит следующее. Мы импортировали в текущее пространство функцию
<code class="highlighter-rouge">run-jetty</code>. Она принимает два параметра — функцию-приложение и словарь
параметров. Опция <code class="highlighter-rouge">join?</code> определяет, будет ли заблокирован текущий тред до
конца работы сервера. Если передать false, сервер будет запущен в фоне. Чтобы
остановить, нужно сохранить его в переменную и вызвать метод <code class="highlighter-rouge">.stop</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">server</span><span class="w">
  </span><span class="p">(</span><span class="nf">run-jetty</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">{</span><span class="no">:port</span><span class="w"> </span><span class="mi">8080</span><span class="w">
                  </span><span class="no">:join?</span><span class="w"> </span><span class="n">false</span><span class="p">}))</span><span class="w">

</span><span class="c1">;; after a while</span><span class="w">
</span><span class="p">(</span><span class="nf">.stop</span><span class="w"> </span><span class="n">server</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Если флаг был <code class="highlighter-rouge">true</code>, как в первом случае, то главный поток повиснет до конца
работы сервера. Придется либо завершить программу, либо нажать <code class="highlighter-rouge">Ctrl-C</code>.</p>

<p>Во время работы сервера откройте браузер по адресу http://127.0.0.1:8080/. Вы
увидите строку из примера выше. Укажите произвольный путь, например <code class="highlighter-rouge">/hello</code>,
<code class="highlighter-rouge">/path/to/file.txt</code>. Ответ сервера изменится.</p>

<h2 id="Подробней-о-запросах-и-ответах">Подробней о запросах и ответах</h2>

<p>В предыдущем примере мы написали приложение, которые печатает метод и путь
запроса. Это важные, но не единственные его поля. Запрос содержит порт и адрес
сервера, строку запроса, тип протокола, заголовки и тело. Уточним, что запрос
это неизменяемый словарь, ключи которого keywords (кейворды или ключевые слова,
в других языках — теги). <a href="https://github.com/ring-clojure/ring/blob/master/SPEC">Полная спецификация</a> запроса и ответа лежит
в репозитории на Гитхабе.</p>

<p>Обратим внимание на поля <code class="highlighter-rouge">:headers</code> и <code class="highlighter-rouge">:body</code>.</p>

<p>Заголовки это неизменяемый словарь, но его ключи не кейворды, а строки. Такой
словарь не работает с destructuring assignment. В примере ниже host получит
значение <code class="highlighter-rouge">nil</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">some-handler</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">headers</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">host</span><span class="p">]}</span><span class="w"> </span><span class="n">headers</span><span class="p">]</span><span class="w">
    </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы извлечь заголовки правильно, используйте <code class="highlighter-rouge">get</code> со строкой:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">headers</span><span class="w"> </span><span class="s">"host"</span><span class="p">)</span><span class="w">
</span><span class="mf">127.0</span><span class="n">.0.1</span><span class="w">
</span></code></pre></div></div>

<p>Заметим, что имя заголовка всегда в нижнем регистре. С точки зрения HTTP, оба
написания <code class="highlighter-rouge">Content-Type</code> и <code class="highlighter-rouge">content-type</code> верны. Сервер принудительно сводит
заголовки к нижнему регистру, чтобы избежать неоднозначности.</p>

<p>Значения заголовков тоже строки. Даже если стандарт HTTP определяет типы
некоторых заголовков, Ring не пытается вывести их. Например, заголовок
<code class="highlighter-rouge">Content-Length</code> передает длину тела в байтах. Современные фреймворки приводят
его к числу и помещают в отдельное поле запроса. По умолчанию Ring не делает
чего-то подобного, но такой функционал легко добавить.</p>

<p>За ключами-строками стоит проблема. Clojure спроектирована так, что почти всегда
ключи словаря это кейворды. Легко забыть о том, что у заголовков они строки. Так
появляются ошибки, когда разработчик деструктурирует заголовки и получает <code class="highlighter-rouge">nil</code>.</p>

<p>Можно обработать словарь заголовков, заменив тип ключей. Для одного случая это
нормально. Но если так делает каждый обработчик, это плохая идея. Правильно
сделать так, чтобы каждая функция получала запрос с уже исправленными
заголовками. Эта техника называется Middleware, и мы рассмотрим ее ниже.</p>

<p>Поле запроса <code class="highlighter-rouge">:body</code> опционально. Вспомним, что согласно HTTP тела может и не
быть. При попытке считать body проверяйте его на <code class="highlighter-rouge">nil</code>.</p>

<p>Обратите внимание на тип body. Это не строка, а входящий поток —
<code class="highlighter-rouge">java.io.InputStream</code>. Поток — это источник данных, который можно прочесть
только раз. По умолчанию Ring не читает поток. Это остается на усмотрение
разработчика.</p>

<p>Вспомним, что чтение и разбор тела это сложная и небезопасная операция. По
заголовкам следует определить тип документа и его длину, прочитать нужное число
байт и восстановить документ в структуру (JSON, XML, etc). Результат каждого
шага следует проверять по разным критериям. Чтобы получить из <code class="highlighter-rouge">Content-Length</code>
число, мы должны быть готовы к исключению во время разбора строки. Но результат
-42 тоже неверный, потому что число байт в потоке не может быть отрицательным.</p>

<p>Технически возможно послать серверу JSON-документ, но указать <code class="highlighter-rouge">Content-Type:
text/xml</code>. Тот, кто это сделал, не обязательно злоумышленник. Это может быть
ошибка в коде на стороне клиента. Сервер должен быть готов к подобному сценарию.</p>

<p>Легче всего считать тело в строку функцией <code class="highlighter-rouge">slurp</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">handler</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">content</span><span class="w">
             </span><span class="p">(</span><span class="nf">some-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="nb">slurp</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">process-content</span><span class="w"> </span><span class="n">content</span><span class="p">))</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Но в современном вебе уже не работают с текстом. Мы работаем с данными —
словарями и объектами. Позже рассмотрим, как Ring переводит байты в данные и
наоборот.</p>

<h3 id="Структура-ответа">Структура ответа</h3>

<p>Ответ Ring устроен проще. Это неизменяемый словарь, в котором только три поля:
<code class="highlighter-rouge">:status</code>, <code class="highlighter-rouge">:headers</code> и <code class="highlighter-rouge">:body</code>.</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">:status</code> — целое положительное число. От статуса зависит успех запроса. Мы
рассмотрели семантику статуса в начале главы.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">:headers</code> — заголовки ответа. В отличии от заголовков запроса, ключи и
значения не обязательно строки. Вариант ниже корректен:</p>
  </li>
</ul>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">302</span><span class="w">
 </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-length</span><span class="w"> </span><span class="mi">0</span><span class="w">
           </span><span class="no">:location</span><span class="w"> </span><span class="s">"/new/page.html"</span><span class="p">}}</span><span class="w">
</span></code></pre></div></div>

<p>Поле <code class="highlighter-rouge">:body</code>, как и в запросе, опционально. В простом случае это строка, но
может быть файлом, ресурсом или потоком. Позже мы рассмотрим интересные сценарии
и техники, связанные с телом ответа.</p>

<h2 id="Маршрутизация">Маршрутизация</h2>

<p>Мы запустили приложение и наблюдали его из браузера. На любой запрос оно выдает
текст с незначительными отличиями. Это проблема. Невозможно поддерживать
приложение, в котором все запросы сходятся в одну точку. Правильно будет
написать отдельный обработчик для каждой бизнес-задачи. Затем как-то
распределить по ним входящие запросы. Это называется маршрутизатор или роутинг.</p>

<p>Вспомним, что в мире Clojure и Ring нет отдельной сущности-роутера. Это будет
функция, которая принимает обработчики (хендлеры) и возвращает
функцию-приложение. Такая функция принимает запрос и по методу и пути подбирает
нужный обработчик. Затем вызывает его с запросом и возвращает ответ.</p>

<p>Сказанное означает, что на верхнем уровне у нас по-прежнему функция. Она
принимает словарь запроса и возвращает словарь ответа. Одинаковый принцип на
всех уровнях.</p>

<p>Рассмотрим тривиальный случай. Вообразим, что адресу “/” мы бы хотели видеть
название сайта, а по “/hello” — приветствие. Все другие адреса возвращают <code class="highlighter-rouge">404
Page not found</code>. Определим обработчики:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-index</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="s">"Learning Web for Clojure"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-hello</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="s">"Hi there and keep trying!"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-404</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">404</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="s">"No such a page."</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Готово. Каждый такой обработчик можно запустить как сервер и проверить в
браузере. Осталось связать их в единое целое.</p>

<h3 id="Наивный-подход">Наивный подход</h3>

<p>Сделаем самое простое, что приходит в голову. Напишем обработчик, который
вручную определяет нужный маршрут. Достаточно проверить путь:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">uri</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">uri</span><span class="w">
      </span><span class="s">"/"</span><span class="w">      </span><span class="p">(</span><span class="nf">page-index</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="s">"/hello"</span><span class="w"> </span><span class="p">(</span><span class="nf">page-hello</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">page-404</span><span class="w"> </span><span class="n">request</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Ответ такой функции зависит от запроса, а именно его пути. Запустите новое
приложение в браузере и проверьте результат для разных адресов. Хоть это и
наивный перебор, но работает.</p>

<p>Недостатки этой функции очевидны. Мы не учитываем метод запроса. “GET /users” и
“POST /users” различны по смыслу. Наша реализация сравнивает пути в лоб без
учета их параметров. С точки зрения правильного роутинга запросы “GET /users/1”
и “GET /users/99” сходятся в один обработчик, но с разным параметром id.</p>

<p>Общий недостаток в том, что код зашумлен. Такую функцию трудно
поддерживать. Хотелось бы описать маршруты правилами, то есть декларативно.</p>

<p>Эти и другие проблемы решены в отдельных Clojure-библиотеках. Мы рассмотрим две
из них: Compojure и Bidi. Каждая библиотека решает задачу роутинга по-своему, их
подходы ортогональны.</p>

<h3 id="compojure">Compojure</h3>

<p>Библиотека <a href="https://github.com/weavejester/compojure/">Compojure</a> предлагает макросы для описания
маршрутов. Макросы устроены так, что их набор похож на таблицу правил. Добавим
зависимость в проект:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">compojure</span><span class="w"> </span><span class="s">"1.6.1"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Вот как выглядит приложение на Compojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">compojure.core</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">GET</span><span class="w"> </span><span class="n">defroutes</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="nf">defroutes</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/"</span><span class="w">      </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-index</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/hello"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-hello</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="n">page-404</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Это гораздо лучше той каши, что мы написали вначале.</p>

<p>Разберемся, что получили на выходе. Переменная app — это функция, которая
принимает запрос. Обратим внимание, что app объявлена не через <code class="highlighter-rouge">def</code> или <code class="highlighter-rouge">defn</code>,
а особенным макросом. Мы поговорим о макросах в отдельной главе. Пока что
скажем, что <code class="highlighter-rouge">defroutes</code> делает две вещи: создает функцию-роутер и связывает ее с
переменной через <code class="highlighter-rouge">defn</code>. Это обвязка, чтобы писать меньше кода.</p>

<p>Макрос принимает набор правил. Правило это форма вида (метод, путь, запрос,
выражение). Первые два правила созданы макросом GET. Читать их следует так: если
метод запроса GET и путь “/”, то для запроса request верни (page-index request).</p>

<p>Правило компилируется в функцию, которая принимает запрос. В начале работы такая
функция проверяет, действительно ли метод и путь запроса совпадают с
заданными. Если да, то функция вычислит выражение и вернет его результат, в
нашем случае <code class="highlighter-rouge">(page-index request)</code>.</p>

<p>Если запрос не удовлетворяет критериям, то правило-функция вернет nil. Это
значит, что следует попробовать следующее правило, и так далее. Макрос defroutes
автоматизирует эти действия. Он оборачивает правила в особый цикл. На каждом
шаге макрос берет очередное правило, применяет к нему запрос и оценивает
результат. Первое отличное от nil значение станет ответом к текущему запросу.</p>

<p>Что будет, если не подошло ни одно правило? Такое вполне возможно. Тогда
приложение вернет nil, и это вызовет ошибку на уровне сервера. Nil не может быть
ответом на запрос, потому что не ясен его смысл.</p>

<p>Чтобы избежать nil, в конец правил добавляют еще одно, такое, что вернет
правильный ответ независимо от запроса. В нашем случае это функция page-404. Ее
результат всегда одинаков. Так мы гарантируем, что даже если запрос не подошел
первым двум правилам, последнее сработает обязательно.</p>

<p>Так работает роутинг на Compojure. Мы пишем обработчики запросов в отдельных
модулях. Затем импортируем их в модуль с роутингом. С помощью макросов GET, POST
и т.д. мы оборачиваем их в правила. Правило возвращает функцию, которая
проверяет, что запрос соответствует критериям. Если да, то результатом будет
вызов обработчика с запросом.</p>

<h3 id="Продвинутые-возможности">Продвинутые возможности</h3>

<p>Выше мы обозначили проблему: правила “GET /users/1” и “GET /users/99” это один и
тот же обработчик, но с параметром. Вот как описать такой путь:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/users/:id"</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">request</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">page-user</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, в пути двоеточие перед id, а третий параметр заключен в
квадратные скобки. Такой синтаксис означает, что часть с двоеточием следует
трактовать как параметр. Compojure поместит его в поле запроса
params. Обработчик <code class="highlighter-rouge">page-user</code> должен извлечь его следующим образом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-user</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">user-id</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:params</span><span class="w"> </span><span class="no">:id</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w"> </span><span class="n">user-id</span><span class="p">)</span><span class="w">
          </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">fname</span><span class="w"> </span><span class="n">lname</span><span class="p">]}</span><span class="w"> </span><span class="n">user</span><span class="p">]</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"User %s is %s %s"</span><span class="w">
                     </span><span class="n">user-id</span><span class="w"> </span><span class="n">fname</span><span class="w"> </span><span class="n">lname</span><span class="p">)})))</span><span class="w">
</span></code></pre></div></div>

<p>В данном случае предположим, что функция <code class="highlighter-rouge">get-user-by-id</code> возвращает словарь
пользователя по его номеру. Из словаря мы извлекаем имя и фамилию, формируем
строку и возвращаем ответ.</p>

<p>Compojure решает проблему вложенных путей. Предположим, приложение показывает и
редактирует товары. По адресу “/content/order/1/view” открывается карточка
товара для просмотра. Страница “/content/order/1/edit” выводит форму
редактирования этого товара. Чтобы сохранить товар, нужно отправить поля формы
по тому же пути, но методом POST.</p>

<p>Очевидно, правила пересекаются. Чтобы избежать повторов, используем макрос context:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">context</span><span class="w"> </span><span class="s">"/content/order/:id"</span><span class="w"> </span><span class="p">[</span><span class="n">order-id</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w">  </span><span class="s">"/view"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">order-view</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">context</span><span class="w"> </span><span class="s">"/edit"</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="p">(</span><span class="nf">GET</span><span class="w">  </span><span class="s">"/"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">order-form</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">POST</span><span class="w"> </span><span class="s">"/"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">order-save</span><span class="w"> </span><span class="n">request</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Каждое правило под макросом context наследует параметры запроса. Это значит,
обработчики order-view, order-form и order-save получат параметр <code class="highlighter-rouge">:order-id</code> из
<code class="highlighter-rouge">:params</code>.</p>

<p>До сих пор в качестве выражения в правилах мы указывали что-то вроде
<code class="highlighter-rouge">(some-handler request)</code>. Бывает, что ответ по данному пути заранее известен,
поэтому нет смысла выносить его в отдельную функцию. Пусть выражение будет
готовым ответом. Рассмотрим это на примере healthcheck-обработчика.</p>

<p>Современные приложения часто запускают в контейнерах и облачных сервисах.  Чтобы
узнать, работает приложение или нет, специальная служба периодически опрашивает
его. Стандартный способ сделать это — послать приложению GET-запрос по адресу
“/health” и проверить статус. Тело и заголовки ответа не играют роли.</p>

<p>Чтобы не создавать лишний обработчик <code class="highlighter-rouge">(page-health request)</code>, поместим ответ в
тело:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ANY</span><span class="w"> </span><span class="s">"/health"</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="no">:body</span><span class="w"> </span><span class="s">"ok"</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Однако, можно сделать еще проще. В Compojure предусмотрен случай, когда
выражение это строка. Compojure трактует такую строку как тело положительного
ответа:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ANY</span><span class="w"> </span><span class="s">"/health"</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="s">"ok"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h3 id="Роутинг-с-bidi">Роутинг с Bidi</h3>

<p>Библиотека <a href="https://github.com/juxt/bidi">Bidi</a> решает проблему роутинга иным способом. Compojure
предлагает макросы, чтобы описать правила и сделать по ним перебор. Bidi
опирается на данные — списки и словари. Сценарий роутинга в Bidi состоит из
нескольких шагов.</p>

<p>На первом этапе объявить особое дерево маршрутов. Это дерево — комбинация
векторов и словарей по определенным правилам. В листьях дерева поместить теги —
уникальные метки для обозначения листа. Особая функция принимает это дерево и
запрос. Функция пытается понять, на какую ветвь дерева ложиться запрос. Если
таковая нашлась, результатом будет тег ветки и, возможно, параметры
пути. Например, <code class="highlighter-rouge">{:route :show-user, :route-params: {:id 1}}</code>.</p>

<p>На втором этапе написать middleware — промежуточный обработчик запроса. Такой
middleware принимает запрос, добавляет в него тег и передает дальше по цепочке.</p>

<p>На третьем этапе — объявить обработчик запроса. Но это будет не функция, а
мультиметод. Его функция-диспачер возвращает тег. Метод <code class="highlighter-rouge">:default</code> возвращает
ответ 404, <code class="highlighter-rouge">:show-user</code> — страницу пользователя, и так далее.</p>

<p>На первый взгляд схема кажется сложной. Но однажды настроив, ее легко
расширять. Чтобы сервер подхватил новый путь, достаточно поместить в дерево
нужную ветку и расширить мультиметод.</p>

<p>Перепишем на Bidi все то, что сделали на Compojure. Добавьте в проект
зависимость:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">bidi</span><span class="w"> </span><span class="s">"2.1.5"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Начнем с дерева маршрутов. Вариант с page-index, page-hello и page-404 будет выглядеть так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">routes</span><span class="w">
  </span><span class="p">[</span><span class="s">"/"</span><span class="w"> </span><span class="p">{</span><span class="s">""</span><span class="w">      </span><span class="no">:page-index</span><span class="w">
        </span><span class="s">"hello"</span><span class="w"> </span><span class="no">:page-hello</span><span class="w">
        </span><span class="n">true</span><span class="w">    </span><span class="no">:not-found</span><span class="p">}])</span><span class="w">
</span></code></pre></div></div>

<p>Проверим, как работает матчинг пути по этому дереву. Функция match-route
принимает маршруты и путь и возвращает словарь с тегом:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">bidi.bidi</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">bidi</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">bidi/match-route</span><span class="w"> </span><span class="n">routes</span><span class="w"> </span><span class="s">"/hello"</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:handler</span><span class="w"> </span><span class="no">:page-hello</span><span class="p">}</span><span class="w">

</span><span class="p">(</span><span class="nf">bidi/match-route</span><span class="w"> </span><span class="n">routes</span><span class="w"> </span><span class="s">"/test"</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:handler</span><span class="w"> </span><span class="no">:not-found</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Ответ функции следует объединить со словарем запроса. Чтобы сделать это за один
шаг, воспользуемся функцией match-route*. Это альтернативная версия match-route,
которая принимает словарь-накопитель.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="w">
      </span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:get</span><span class="w">
       </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/test"</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="nf">bidi/match-route*</span><span class="w"> </span><span class="n">routes</span><span class="w"> </span><span class="p">(</span><span class="no">:uri</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">

</span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:get</span><span class="w">
 </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/test"</span><span class="w">
 </span><span class="no">:handler</span><span class="w"> </span><span class="no">:not-found</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Видим, что <code class="highlighter-rouge">match-route*</code> вернула переданный запрос, но добавила в него поле
handler. Перенесем код выше в middleware. Это функция, которая принимает
обработчик запроса и возвращает его альтернативную версию. Такой обработчик,
получив запрос, сперва добавит к нему поле handler и вызовет исходный обработчик
с новым запросом.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-handler</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">uri</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
          </span><span class="n">request*</span><span class="w"> </span><span class="p">(</span><span class="nf">bidi/match-route*</span><span class="w">
                    </span><span class="n">routes</span><span class="w"> </span><span class="n">uri</span><span class="w"> </span><span class="n">request</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="n">request*</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Мы еще не касались техники middleware, но вынуждены применить ее на данном
этапе.  Ниже мы рассмотрим во деталях, как устроены middleware и почему так
важны.</p>

<p>Проверим <code class="highlighter-rouge">wrap-handler</code> на скорую руку. Будем считать, что обработчик запроса
это стандартная функция identity. Она всегда возвращает переданный в нее
аргумент:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="nf">wrap-handler</span><span class="w"> </span><span class="nb">identity</span><span class="p">)</span><span class="w">
 </span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:get</span><span class="w">
  </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/hello?foo=42"</span><span class="p">})</span><span class="w">

</span><span class="p">{</span><span class="no">:request-method</span><span class="w"> </span><span class="no">:get,</span><span class="w">
 </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/hello?foo=42"</span><span class="n">,</span><span class="w">
 </span><span class="no">:handler</span><span class="w"> </span><span class="no">:page-hello</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Конечный обработчик запроса будет мультиметодом. Его функция-диспатчер просто
<code class="highlighter-rouge">:handler</code>.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmulti</span><span class="w"> </span><span class="n">multi-handler</span><span class="w">
  </span><span class="no">:handler</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">multi-handler</span><span class="w"> </span><span class="no">:page-index</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="s">"Learning Web for Clojure"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">multi-handler</span><span class="w"> </span><span class="no">:page-hello</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="s">"Learning Web for Clojure"</span><span class="p">})</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">multi-handler</span><span class="w"> </span><span class="no">:not-found</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">404</span><span class="w">
   </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="s">"No such a page."</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>Теперь обернем <code class="highlighter-rouge">multi-handler</code> в middleware. Это и будет финальное приложение.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nf">wrap-handler</span><span class="w"> </span><span class="n">multi-handler</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Запустите веб-сервер и проверьте результат в браузере.</p>

<p>Это был простой вариант роутинга на Bidi. Рассмотрим пример с заказами:
просмотр, редактирование и сохранение.</p>

<p>Новое дерево выглядит так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">routes</span><span class="w">
  </span><span class="p">[</span><span class="s">"/"</span><span class="w"> </span><span class="p">{[</span><span class="s">"content/order/"</span><span class="w"> </span><span class="no">:id</span><span class="p">]</span><span class="w">
        </span><span class="p">{</span><span class="s">"/view"</span><span class="w"> </span><span class="p">{</span><span class="no">:get</span><span class="w">  </span><span class="no">:page-view</span><span class="p">}</span><span class="w">
         </span><span class="s">"/edit"</span><span class="w"> </span><span class="p">{</span><span class="no">:get</span><span class="w">  </span><span class="no">:page-form</span><span class="w">
                  </span><span class="no">:post</span><span class="w"> </span><span class="no">:page-save</span><span class="p">}}}])</span><span class="w">
</span></code></pre></div></div>

<p>В этой версии листья уже не теги, а словари. Ключ такого словаря — метод
HTTP-запроса, а значение — тег. Запрос “GET /content/order/1/edit” разрешается в
тег <code class="highlighter-rouge">:page-form</code>, а POST с таким же адресом — в <code class="highlighter-rouge">:page-save</code>. При прохождении
через wrap-handler запрос получит поле route-params. Для нашего случая это будет
словарь <code class="highlighter-rouge">{:id "1"}</code>.</p>

<p>Вот так бы мог выглядеть обработчик <code class="highlighter-rouge">page-edit</code>. Получаем словарь заказа по его
id. Если заказ найден, рисуем HTML страницу с формой редактирования. Если нет,
отдаем 404 и сообщение об ошибке.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">multi-handler</span><span class="w"> </span><span class="no">:page-edit</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">order-id</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">[</span><span class="no">:route-params</span><span class="w"> </span><span class="no">:id</span><span class="p">])</span><span class="w">
        </span><span class="n">order</span><span class="w"> </span><span class="p">(</span><span class="nf">get-order-by-id</span><span class="w"> </span><span class="n">order-id</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">order</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
       </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/html"</span><span class="p">}</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">render-order-form</span><span class="w"> </span><span class="n">order</span><span class="p">)}</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">404</span><span class="w">
       </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/html"</span><span class="p">}</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="s">"&lt;h1&gt;Order not found&lt;/h1&gt;"</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<h3 id="Выбор-между-compojure-и-bidi">Выбор между Compojure и Bidi</h3>

<p>Автору приходилось работать с роутингом обоих типов. По субъективным ощущениям,
с Compojure легче начать. У библиотеки достойная документация с
примерами. Compojure написал тот же разработчик, что и Ring. Проекты близки и
дополняют друг друга.</p>

<p>Дерево маршрутов Bidi сложно для понимания. Оно многословно и не
интуитивно. Легко допустить ошибку, перепутать вектор и словарь. С другой
стороны, логика на мультиметодах несет преимущества. Код становится линейным,
более организованным, приложение легче наращивать.</p>

<p>Если вы начинающий Clojure-разработчик или проект небольшой, выбирайте
Compojure. Когда проект сложный со множеством эндпоинтов, рассмотрите переезд на
Bidi.</p>

<h2 id="middleware">Middleware</h2>

<p>Выше мы упоминали про middleware и даже кинули пробный шар — написали
wrap-route. В этом разделе мы разберем все вопросы о middleware и лучших
практиках по работе с ними. Автор считает этому тему самой важной в главе.</p>

<p>В переводе с английского Middleware значит промежуточный слой, середина. В
программировании под middleware понимают код, который обрабатывает данные между
посредниками. Обработка данных это приведение типов, добавление новых полей,
проверка прав доступа.</p>

<p>Паттерн “декоратор” это частный случай middleware. Декоратор это функция А,
которая принимает функцию B и возвращает функцию C. Говорят, что A декорирует
B. Результат декорирования это C. В ходе исполнения функция C вызывает B, но с
изменениями. Например, корректирует входные или выходные данные B.</p>

<p>Приведем примеры простых декораторов. with-echo добавляет к функции побочные
эффекты: печатает аргументы и результат.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">with-echo</span><span class="w">
  </span><span class="p">[</span><span class="n">func</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">println</span><span class="w"> </span><span class="s">"The args are"</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"The result is"</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w">
      </span><span class="n">result</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><code class="highlighter-rouge">With-catch</code> оборачивает целевую функцию в форму <code class="highlighter-rouge">try/catch</code>. Если во время
работы выброшено исключение, результатом будет его объект.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">with-catch</span><span class="w">
  </span><span class="p">[</span><span class="n">func</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">try</span><span class="w">
      </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="n">e</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Мы уже рассматривали структуру Ring-запроса. Возможно, читатель заметил, что в
нем нет полей, с которыми он работал в других языках. Например, классы
<code class="highlighter-rouge">django.http.HttpRequest</code> и <code class="highlighter-rouge">flask.Request</code> в Python содержат поля <code class="highlighter-rouge">.params</code> или
<code class="highlighter-rouge">.values</code>. Это словари, полученные из адресной строки или тела запроса.</p>

<p>Почему в стандарте Ring нет столь важных вещей? Потому что не каждое приложение
в них нуждается. Фреймворк предоставляет только базовую информацию о
запросе. Остальные данные могут быть получены из исходных.</p>

<p>Представим, что на каждый запрос Ring парсит строку параметров и тело. Это
удобно разработчику, но резко снижает производительность сервера. Нет гарантии,
что параметры строки пригодятся в запросе. Но сервер потратит время и память на
их обработку. Еще хуже с обработкой тела. Вспомним, что это дорогая
операция. Возможен сценарий, когда сервер прочитал огромный JSON-документ, но
внутри обработчика выяснилось, что у пользователя нет прав на запись. Эту
проверку следовало выполнить раньше!</p>

<p>Как мы помним, обработчик запроса в Ring это функция, которая принимает запрос и
возвращает ответ. Техника middleware как нельзя лучше подходит, чтобы добавить
промежуточную логику. Параметры запроса, сессии, куки, права доступа — все это
функция, которая возвращает функцию.</p>

<p>Вам не придется писать все middleware с нуля. Ring уже содержит основные из
них. Остается только применить их к приложению. Рассмотрим некоторые middleware
и принципы их работы.</p>

<h3 id="Параметры-запроса">Параметры запроса</h3>

<p>Стандарт HTTP разрешает передавать данные в адресной строке. Это пары вида
“name=John&amp;city=NY” после знака вопроса. Удобно, когда параметры доступны в виде
словаря. В нашем случае это была бы структура <code class="highlighter-rouge">{:name "John" :city "NY"}</code>.</p>

<p>Аналогично с параметрами из тела запроса. Их передают в теле по разным
причинам. В основном это ограничение на длину и проблемы безопасности. Длина
адресной строки ограничена 2048 байтами, в то время как на тело запроса
ограничений нет. Пароли и адреса почты небезопасно передавать в адресной строке,
потому что они остаются в логах и истории браузера.</p>

<p>Функция wrap-params из модуля ring.middleware.params меняет функцию-обработчик
следующим образом. Переданный в нее запрос дополняется тремя полями:</p>

<ul>
  <li><code class="highlighter-rouge">:query-params</code> — словарь параметров адресной строки;</li>
  <li><code class="highlighter-rouge">:form-params</code> — словарь данных из тела запроса;</li>
  <li><code class="highlighter-rouge">:params</code> — их комбинированная версия.</li>
</ul>

<p>Пусть <code class="highlighter-rouge">app</code> — ваше веб-приложение. Чтобы получить его обернутую версию,
достаточно вызвать wrap-params c app. Результат будет финальным приложением. На
жаргоне разработчиков это называется “врапнуть” (анг. wrap — обернуть).</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.params</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-params</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">final-app</span><span class="w">
  </span><span class="p">(</span><span class="nf">wrap-params</span><span class="w"> </span><span class="n">app</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы не запутаться в именах, придерживайтесь правил. Не обернутое приложение
называйте <code class="highlighter-rouge">app-naked</code> или <code class="highlighter-rouge">app-raw</code> (голое, сырое), а финальное просто <code class="highlighter-rouge">app</code>.</p>

<p>Доработайте веб-приложение из примера выше так, чтобы оно учитывало параметры
строки. Например, чтобы имя того, кого приветствовать, можно было задать
параметром who: /hello?who=John.</p>

<p>Подсказка: добраться до параметра who можно так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-hello</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">who</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">[</span><span class="no">:params</span><span class="w"> </span><span class="s">"who"</span><span class="p">])]</span><span class="w">
    </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>или так:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-hello</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">who</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:params</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="s">"who"</span><span class="p">))]</span><span class="w">
    </span><span class="n">...</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Обратите внимание, что ключи <code class="highlighter-rouge">:params</code> это строки. Это нормально, но Clojure
всячески поощряет нас, когда ключи словаря кейворды. Исправим это. В поставке
Ring есть особое middleware, которое приводит поле <code class="highlighter-rouge">:params</code> к удобному
виду. Это <code class="highlighter-rouge">wrap-keyword-params</code> из модуля <code class="highlighter-rouge">ring.middleware.keyword-params</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.keyword-params</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-keyword-params</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nf">wrap-keyword-params</span><span class="w"> </span><span class="p">(</span><span class="nf">wrap-params</span><span class="w"> </span><span class="n">app-naked</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Мы подошли к новой проблеме: когда врапперов много, от них возникает
шум. Типичное приложение включает десять-пятнадцать middleware:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nf">wrap-something-else</span><span class="w">
    </span><span class="p">(</span><span class="nf">wrap-current-user</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-session</span><span class="w">
        </span><span class="p">(</span><span class="nf">wrap-keyword-params</span><span class="w">
          </span><span class="p">(</span><span class="nf">wrap-params</span><span class="w"> </span><span class="n">app-naked</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>Это кашу невозможно поддерживать. Представьте, что требуется добавить еще один
враппер где-то в середине. Это каскадно сдвинет элементы ниже. Чтобы победить
сложность, сделаем структуру линейной. Применим стрелочный оператор:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">app-naked</span><span class="w">
      </span><span class="n">wrap-params</span><span class="w">
      </span><span class="n">wrap-keyword-params</span><span class="w">
      </span><span class="n">wrap-session</span><span class="w">
      </span><span class="n">wrap-current-user</span><span class="w">
      </span><span class="n">wrap-something-else</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Такая форма напоминает обычный список, поэтому ее легко поддерживать.</p>

<p>Запись в стрелочном виде имеет особенность. Не заглядывая в следующее
предложение, догадайтесь, в каком порядке будут выполнены middleware? Правильный
ответ: снизу вверх для запроса и сверху вниз для ответа. Это может показаться
странным, но становится очевидным при мысленном разборе.</p>

<p>Сперва запрос зайдет в <code class="highlighter-rouge">wrap-something-else</code>. Код внутри него вызовет
обработчик, который получен из <code class="highlighter-rouge">wrap-current-user</code>. Обработчик внутри него –
результат <code class="highlighter-rouge">wrap-session</code>, и так далее. Вершиной подъема станет
<code class="highlighter-rouge">app-naked</code>. Структура ответа начнет опускаться по стеку вниз. Сначала он
пройдет через <code class="highlighter-rouge">wrap-params</code> и <code class="highlighter-rouge">wrap-keyword-params</code>. Эти два middleware не
изменяют ответ и просто возвращают его. <code class="highlighter-rouge">Wrap-session</code> и <code class="highlighter-rouge">wrap-current-user</code>,
возможно, допишут в него новые заголовки. Последним сработает
<code class="highlighter-rouge">wrap-something-else</code>. Цикл запроса и ответа пройден.</p>

<p>Цепочку middleware следует рассматривать как восхождение в гору и спуск с
нее. Другой аналогией может быть пузырек, который всплывает и опускается (не
имеет отношения к сортировке пузырьком).</p>

<p>По тому же принципу устроены middleware в Django, промышленном
Python-фреймворке. Хоть в Django их роль играют не функции, а классы, их порядок
обхода такой же.</p>

<p>Порядок middleware порой критичен. Некоторые из них опираются на данные, которые
подготовили предыдущие middleware. Рассмотрим уже знакомые <code class="highlighter-rouge">wrap-params</code> и
<code class="highlighter-rouge">wrap-keyword-params</code>. Последний отыскивает в запросе поле params и меняет тип
ключей. Подразумевается, что params был подготовлен
<code class="highlighter-rouge">wrap-keyword-params</code>. Поэтому <code class="highlighter-rouge">wrap-keyword-params</code> ставят строго после
<code class="highlighter-rouge">wrap-params</code>.</p>

<p>Посмотрим на форму <code class="highlighter-rouge">(def app...)</code> выше. В нее закралась ошибка. Запрос
поднимается снизу вверх, поэтому <code class="highlighter-rouge">wrap-keyword-params</code> сработает раньше. Он
попытается найти поле params в запросе, но безуспешно. Следом сработает
<code class="highlighter-rouge">wrap-params</code>. Он заполнит это поле словарем из адресной строки. В результате
params будет словарем с ключами-строками. В следует поменять wrap-params и
<code class="highlighter-rouge">wrap-keyword-params</code> местами.</p>

<p>Неверный порядок middleware стоит часов отладки. Но есть трюк. Если два и более
middleware идут в строгой последовательности, можно “схлопнуть” их в одно
целое. Стандартная функция comp принимает произвольное число функций и
возвращает супер-функцию, которая последовательно применяет их к
аргументу. Определим умный враппер параметров:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">wrap-params+</span><span class="w">
  </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="n">wrap-keyword-params</span><span class="w"> </span><span class="n">wrap-params</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Плюс на конце означает, что это улучшенная версия обычного wrap-params. Теперь
заменим в стеке <code class="highlighter-rouge">wrap-params</code> и <code class="highlighter-rouge">wrap-keyword-params</code> на <code class="highlighter-rouge">wrap-params+</code>. Цепочка
middleware станет короче, а логика параметров соберется в отдельном месте.</p>

<p>Перечислим другие полезные middleware. Мы не будем останавливаться на детальном
описании каждого. Это скорее индекс, к которому можно обратиться в случае
надобности.</p>

<h3 id="cookie">Cookie</h3>

<p>В стандарте HTTP куки — это маленькие кусочки информации. Между сервером и
браузером особое соглашение о том, как хранить и передавать их. Если сервер
выставил куки, браузер запоминает их для этого сайта. В следующий раз браузер
отправит куки на сервер автоматически. Так продолжается до тех пор, пока сервер
не удалит куки или истечет их срок жизни.</p>

<p>Простейший случай, когда нужны куки — определить, был ли уже пользователь на
сайте. При первом визите приложение ищет в запросе куки с именем visited. Если
значение не установлено, сервер выставляет заголовок вроде:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set-Cookie: visited=true;
</code></pre></div></div>

<p>В последующих запросах браузер отправит это значение на сервер
самостоятельно. Приложение проверяет: если <code class="highlighter-rouge">visited true</code>, значит пользователь
уже был на сайте. Такие проверки влияют на показ рекламы, всплывающие окна,
попапы с обновлениями.</p>

<p>Технически куки — это один длинный заголовок, где значения и атрибуты разделены
специальными точками с запятой. Middleware wrap-cookie значительно облегчает
работу с куки. Во время запроса заголовок преображается в словарь в поле
<code class="highlighter-rouge">:cookies</code>. Чтобы сообщить клиенту новые куки, добавьте поле <code class="highlighter-rouge">:cookies</code> в
ответ. Из такого словаря образуется заголовок <code class="highlighter-rouge">Set-Cookie</code>.</p>

<p>Напишем простую страничку, которая определяет, видим ли мы ее в первый раз.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.cookies</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-cookies</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-seen</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">seen-path</span><span class="w"> </span><span class="p">[</span><span class="no">:seen</span><span class="w"> </span><span class="no">:value</span><span class="p">]</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">cookies</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="n">seen?</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">cookies</span><span class="w"> </span><span class="n">seen-path</span><span class="p">)</span><span class="w">
        </span><span class="n">cookies</span><span class="w"> </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="n">cookies</span><span class="w"> </span><span class="n">seen-path</span><span class="w"> </span><span class="n">true</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:cookies</span><span class="w"> </span><span class="n">cookies</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">seen?</span><span class="w">
             </span><span class="s">"Already seen"</span><span class="w">
             </span><span class="s">"The first time you see it"</span><span class="p">)</span><span class="w"> </span><span class="p">}))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">page-seen</span><span class="w">
      </span><span class="n">wrap-cookies</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Запустите приложение в браузере. После обновления страницы надпись изменится на
“Already seen”. Обратите внимание, что даже после перезагрузки сервера ответ
по-прежнему будет “Already seen”, потому что флаг хранится в браузере. Только
очистив куки вы снова увидите “The first time you see it”. Для полноты
эксперимента откройте приватную вкладку или другой браузер.</p>

<p>Куки тесно связаны с безопасностью. Даже если вам понятны технические детали,
убедитесь, что куки защищены от кражи и не раскрывают секретные данные (пароли,
ключи доступа). В этом разделе мы не обсуждаем тему веб-безопасности. Она
слишком обширна для этой главы и заслуживает отдельной книги.</p>

<h3 id="Сессии">Сессии</h3>

<p>Стандарт HTTP не предполагает связи между двумя запросами. Считается, что два
запроса с соседних компьютеров разницей в пять минут связаны так же, как с
разных континентов разницей в год. Но сразу с рождения веба разработчики
нарушили стандарт. Понадобилось хранить состояние конкретного пользователя. Даже
если компьютеры за одним столом, сервер должен различать их. Это назвали сессией
или сеансом.</p>

<p><code class="highlighter-rouge">Wrap-session</code> это довольно сложное middleware. Оно дополняет запрос полем
<code class="highlighter-rouge">:session</code>, в котором словарь. Его ключи — поля сессии. Чтобы обновить сессию,
следует положить ее новую версию в ответ по аналогии с <code class="highlighter-rouge">:cookie</code>. Middleware
различает <code class="highlighter-rouge">nil</code> и факт отсутствия сессии в ответе. Если поле <code class="highlighter-rouge">:session</code> <code class="highlighter-rouge">nil</code>, вся
сессия удаляется. Если ключа нет, ничего не происходит.</p>

<p>Сессия это абстрактное понятие, поэтому различают бэкенды сессии. Это разные
способы хранить значения физически. Сессия может храниться в памяти, на диске, в
базе данных, Memcached/Redis или даже куках. При выборе бэкенда важно учитывать,
способен ли он работать на нескольких машинах одновременно. Что получится, если
каждый запрос на случайно выбранной из десяти машин?</p>

<p>Если сессия хранится в памяти приложения, то на каждой машине будет ее разная
версия. Это чревато странным поведением и трудной отладкой. Аналогично с файлами
— машины не делят их между собой. А вот база данных или Redis это общее
хранилище. Оно гарантирует актуальность сессии для всех клиентов.</p>

<p>Интересно, что сессия на базе куки тоже работает на множестве машин. На каждый
запрос браузер передает и получает полную сессию в HTTP-заголовках. В этом
случае сессия хранится на клиенте. Но если пользователь очистит куки или
запустит другой браузер, сессия будет утеряна.</p>

<p>В стандартной поставке Ring сессия хранится в памяти или куках. Хранилище
определяется настройками wrap-session. Ring закладывает необходимые абстракции,
чтобы хранить сессию в базе или key-value системах типа Redis.</p>

<p>Рассмотрим пример со счетчиком посещений. Будем считать, сколько раз
пользователь зашел на наш сайт. Для простоты храним сессию в памяти.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.session</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-session</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-counter</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">session</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="n">session</span><span class="w"> </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="n">session</span><span class="w"> </span><span class="no">:counter</span><span class="w"> </span><span class="p">(</span><span class="nf">fnil</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">0</span><span class="p">))]</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:session</span><span class="w"> </span><span class="n">session</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Seen %s time(s)"</span><span class="w"> </span><span class="p">(</span><span class="no">:counter</span><span class="w"> </span><span class="n">session</span><span class="p">))}))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">page-counter</span><span class="w">
      </span><span class="n">wrap-session</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Запустите app в веб-сервере и откройте браузер. Обновляйте страницу, и счетчик в
сообщении возрастет с каждым просмотром. Ради интереса проделайте то же самое в
другом браузере. Это будет вторая сессия, которая не зависит от
первой. Поскольку данные хранится в памяти, они будут утеряны при перезагрузке
сервера.</p>

<p>Упражнение: в примере выше мы считаем просмотры для всего сайта. Сделайте так,
чтобы счетчик работал в рамках страниц. Например, главная страница <code class="highlighter-rouge">/</code>
просмотрена пять раз, а справка <code class="highlighter-rouge">/help</code> — три раза. Параметры командной строки
не влияют на подсчет.</p>

<h3 id="json">JSON</h3>

<p>Формат JSON предназначен для передачи данных. Среду прочих его достоинств —
типы, вложеность и совместимость с JavaScript.</p>

<p>JSON различает базовые типы данных — числа, строки, логический тип. Это выгодно
отличает его от параметров адресной строки или XML, где все значения строки.</p>

<p>Формат предусматривает основные коллекции — массив и словарь — и их произвольную
вложенность. В разное время были попытки передать вложенные данные в адресной
строке. Общий подход был в том, чтобы ключ содержал путь внутри
структуры. Например, если в данных несколько адресов, а у каждого адреса
несколько строк (line 1, line 2, etc), то получается что-то вроде:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>address[0].line[0].value=SomeStreet
</code></pre></div></div>

<p>Требовалось писать и поддерживать код для работы с такими парами. Каждый
фреймворк нес на борту собственный модуль, чтобы упаковывать и восстанавливать
коллекции. К счастью, сегодня с этим покончено. Сегодня только старые системы
передают коллекции через командную строку.</p>

<p>JSON совместим с JavaScript. Если передать такой документ в функцию <code class="highlighter-rouge">eval</code>, она
вернет данные — комбинацию списков и словарей.</p>

<p>Все это способствовало тому, чтобы JSON стал главным способом передать данные в
интернете.</p>

<p>Ring предлагает набор middleware для JSON. Они вынесены в отдельный пакет для
удобства разработки. Добавим в проект зависимость:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ring/ring-json</span><span class="w"> </span><span class="s">"0.4.0"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>wrap-json-response облегчает возврат JSON-данных. Это middleware проверяет поле
ответа <code class="highlighter-rouge">:body</code>. Если это коллекция (вектор, словарь), то middleware заменяет его
на кодированную строку и выставляет заголовок <code class="highlighter-rouge">Content-Type: application/json</code>.</p>

<p>Рассмотрим пример:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.json</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-json-response</span><span class="p">]])</span><span class="w">


</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-data</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
   </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:some</span><span class="w"> </span><span class="p">{</span><span class="no">:json</span><span class="w"> </span><span class="p">[</span><span class="s">"data"</span><span class="p">]}}})</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">page-data</span><span class="w">
      </span><span class="n">wrap-json-response</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Более сложный пример. Если пользователь нашелся, возвращаем его модель. Если
нет, то структуру ошибки.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-data</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user-id</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:params</span><span class="w"> </span><span class="no">:id</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w"> </span><span class="n">user-id</span><span class="p">)]</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="n">user</span><span class="p">}</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">404</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:error_code</span><span class="w"> </span><span class="s">"MISSING_USER"</span><span class="w">
              </span><span class="no">:error_message</span><span class="w"> </span><span class="s">"No such a user"</span><span class="w">
              </span><span class="no">:error_data</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="n">user-id</span><span class="p">}}})))</span><span class="w">
</span></code></pre></div></div>

<p>Для входящего JSON-документа в библиотеке два middleware. Это <code class="highlighter-rouge">wrap-json-body</code> и
<code class="highlighter-rouge">wrap-json-params</code>. На фазе запроса оба проверяют, что заголовок <code class="highlighter-rouge">Content-Type</code>
содержит <code class="highlighter-rouge">application/json</code>. Если да, они парсят тело с учетом возможных
исключений. При ошибке разбора ответ будет 400 “JSON body malformed”.</p>

<p>Разница между <code class="highlighter-rouge">wrap-json-body</code> и <code class="highlighter-rouge">wrap-json-params</code> в том, куда они складывают
полученные данные.</p>

<p><code class="highlighter-rouge">Wrap-json-body</code> заменяет поле <code class="highlighter-rouge">:body</code> запроса на полученную структуру данных. В
примере ниже обработчик <code class="highlighter-rouge">page-body</code> извлекает имя и город пользователя из
<code class="highlighter-rouge">:body</code>. Тело запроса уже не входящий поток, а структура данных, о чем заботится
<code class="highlighter-rouge">wrap-json-body</code>. Обратите внимание, middleware принимает опциональные
параметры. Флаг <code class="highlighter-rouge">:keywords? true</code> Означает, что ключи словарей должны быть
приведены к кейвордам.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.json</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-json-body</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-body</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">body</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">username</span><span class="w"> </span><span class="n">city</span><span class="p">]}</span><span class="w"> </span><span class="n">body</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">create-user</span><span class="w"> </span><span class="n">username</span><span class="w"> </span><span class="n">city</span><span class="p">)</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:code</span><span class="w"> </span><span class="s">"CREATED"</span><span class="w">
            </span><span class="no">:message</span><span class="w"> </span><span class="s">"User created"</span><span class="p">}}))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">page-body</span><span class="w">
      </span><span class="p">(</span><span class="nf">wrap-json-body</span><span class="w"> </span><span class="p">{</span><span class="no">:keywords?</span><span class="w"> </span><span class="n">true</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Чтобы отправить JSON-запрос к серверу, понадобится специальная программа. Это
может быть утилита cURL или графическое приложение Postman. Пример с cURL:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="se">\</span>
  <span class="nt">--header</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">--request</span> POST <span class="se">\</span>
  <span class="nt">--data</span> <span class="s1">'{"username":"John","city":"NY"}'</span> <span class="se">\</span>
  http://localhost:8080/
</code></pre></div></div>

<p>Вариант с <code class="highlighter-rouge">wrap-json-params</code> Отличается тем, где хранится структура данных. Это
middleware заносит данные в поле <code class="highlighter-rouge">:json-params</code>. В дополнение, если данные были
словарем, они вливаются в поле <code class="highlighter-rouge">:params</code>. Это поле, как мы помним, используются
другими врапперами, например, <code class="highlighter-rouge">wrap-params</code>.</p>

<p>Таким образом, <code class="highlighter-rouge">:params</code> выступает универсальным аккумулятором
параметров. Продвинутое API может быть устроено так, что клиент вправе
передавать данные удобным ему способом. Например, GET-запросом с параметрами
строки, если это данные для чтения. POST с переменными в теле, чтобы изменять
сущности. Или POST с JSON-телом, если данные с глубокой вложенностью.</p>

<p>Вспомним, что params это словарь с ключам-строками. По этой причине
<code class="highlighter-rouge">wrap-json-params</code> сохраняет строки в ключах, чтобы слияние прошло
правильно. Чтобы исправить ключи <code class="highlighter-rouge">:params</code> на кейворды, используйте уже знакомое
нам <code class="highlighter-rouge">wrap-keyword-params</code>. Оно должно быть ниже <code class="highlighter-rouge">wrap-json-params</code> по стеку.</p>

<p>Разработчики не случайно выделяют поле <code class="highlighter-rouge">:json-params</code>. Тело JSON-документа не
обязательно словарь, это может быть массив. Такую структуру невозможно влить в
<code class="highlighter-rouge">:params</code>. Документ помещают в <code class="highlighter-rouge">:json-params</code>, и если это словарь, объединяют с
<code class="highlighter-rouge">:params</code>.</p>

<p>Продемонстрируем сказанное на примере. Передаем данные гибридно: <code class="highlighter-rouge">username</code> в
теле JSON-документа и <code class="highlighter-rouge">city</code> в параметрах строки. Обратите внимание на стек
middleware. Сперва мы парсим параметры строки, затем тело документа. Оба словаря
накапливаются в <code class="highlighter-rouge">:params</code>. Затем, уже после их накопления, исправляем тип
ключей.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">ring.middleware.json</span><span class="w">
           </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">wrap-json-params</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">page-params</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">params</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="w">
        </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">username</span><span class="w"> </span><span class="n">city</span><span class="p">]}</span><span class="w"> </span><span class="n">params</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">create-user</span><span class="w"> </span><span class="n">username</span><span class="w"> </span><span class="n">city</span><span class="p">)</span><span class="w">
    </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">200</span><span class="w">
     </span><span class="no">:body</span><span class="w"> </span><span class="p">{</span><span class="no">:code</span><span class="w"> </span><span class="s">"CREATED"</span><span class="w">
            </span><span class="no">:message</span><span class="w"> </span><span class="s">"User created"</span><span class="p">}}))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">page-params</span><span class="w">
      </span><span class="n">wrap-keyword-params</span><span class="w">
      </span><span class="n">wrap-json-params</span><span class="w">
      </span><span class="n">wrap-params</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Пример обращения к серверу:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="se">\</span>
  <span class="nt">--header</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">--request</span> POST <span class="se">\</span>
  <span class="nt">--data</span> <span class="s1">'{"username":"John"}'</span> <span class="se">\</span>
  http://localhost:8080/?city<span class="o">=</span>NY
</code></pre></div></div>

<h3 id="Собственные-middleware">Собственные middleware</h3>

<p>До сих пор мы использовали сторонние врапперы. Это те, что идут в поставке Ring
и смежных библиотек. Но рано или поздно вам потребуются собственные. Обычно их
накапливают в модуле с именем <code class="highlighter-rouge">&lt;projectname&gt;.middleware</code>. Рассмотрим примеры из
реальных проектов.</p>

<h4 id="wrap-headers-kw">wrap-headers-kw</h4>

<p>Этот простой враппер меняет ключи заголовков со строковых на кейворды. Полезно,
когда приложение часто обращается к заголовкам.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w">
 </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.walk</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">keywordize-keys</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-headers-kw</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w">
      </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:headers</span><span class="w"> </span><span class="n">keywordize-keys</span><span class="p">)</span><span class="w">
      </span><span class="n">handler</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<h4 id="wrap-request-id">wrap-request-id</h4>

<p>В протоколе HTTP запрос и ответ не связаны друг с другом. Порой трудно понять, к
какому запросу относится тот или иной ответ и наоборот. Важно, чтобы система
могла их сопоставить. Например, была серия ответов с кодом 500, но какие именно
запросы вызвали ошибку?</p>

<p>Для этого ввели заголовок <code class="highlighter-rouge">X-Request-Id</code>. Если клиент не передал идентификатор
запроса, мы назначаем ему случайный. Тот же идентификатор возвращаем в
ответе. Все записи в лог содержат этот идентификатор.</p>

<p>Обратите внимание, что мы обращаемся к заголовкам как к ключевым словам. Мы
ожидаем, что <code class="highlighter-rouge">wrap-headers-kw</code> был выше по стеку.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">import</span><span class="w"> </span><span class="ss">'java.util.UUID</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-request-id</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">uuid</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">[</span><span class="no">:headers</span><span class="w"> </span><span class="no">:x-request-id</span><span class="p">])</span><span class="w">
                   </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nf">UUID/randomUUID</span><span class="p">)))]</span><span class="w">
      </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w">
          </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="p">[</span><span class="no">:headers</span><span class="w"> </span><span class="no">:x-request-id</span><span class="p">]</span><span class="w"> </span><span class="n">uuid</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="no">:request-id</span><span class="w"> </span><span class="n">uuid</span><span class="p">)</span><span class="w">
          </span><span class="n">handler</span><span class="w">
          </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="p">[</span><span class="no">:headers</span><span class="w"> </span><span class="no">:x-request-id</span><span class="p">]</span><span class="w"> </span><span class="n">uuid</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Мы храним идентификатор не только в заголовках, но и на уровне запроса в поле
<code class="highlighter-rouge">:request-id</code>. Для записи в лог мы будем часто обращаться к нему. Поэтому
вынесем в отдельную переменную вместе с другими полями в начале функции:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">some-handler</span><span class="w">
  </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">params</span><span class="w"> </span><span class="n">request-id</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">log/info</span><span class="w"> </span><span class="s">"Request id: %s"</span><span class="w"> </span><span class="n">request-id</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<h4 id="wrap-current-user">wrap-current-user</h4>

<p>Этот враппер определяет текущего пользователя системы. Стратегия в том, что в
запросе содержится идентификатор пользователя. В данном случае мы ищем его в
сессии. Если идентификатор найден, читаем модель пользователя и присоединяем к
запросу. Ожидается, что функция <code class="highlighter-rouge">get-user-by-id</code> знает, как извлекать данные о
пользователе. Чаще всего это запрос к базе данных.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-current-user</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">user-id</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="no">:session</span><span class="w"> </span><span class="no">:user-id</span><span class="p">)</span><span class="w">
          </span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">user-id</span><span class="w">
                 </span><span class="p">(</span><span class="nf">get-user-by-id</span><span class="w"> </span><span class="n">user-id</span><span class="p">))]</span><span class="w">
      </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">request</span><span class="w">
          </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="no">:user</span><span class="w"> </span><span class="n">user</span><span class="p">)</span><span class="w">
          </span><span class="n">handler</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Условно говоря, хранить <code class="highlighter-rouge">user-id</code> в сессии безопасно. Сессия подписана секретным
ключом, поэтому только сервер может менять ее значения. Не допускайте, чтобы
<code class="highlighter-rouge">user-id</code> передавался в параметрах командной строки.</p>

<h3 id="Прерывание-стека">Прерывание стека</h3>

<p>Выше мы рассмотрели непрерывную цепочку middleware, где каждое звено передает
управление следующему. Но логика middleware не всегда линейна. Бывает, цепочку
необходимо разорвать. Например, еще на уровне middleware мы определили, что
пользователь не имеет прав к данному ресурсу. Продолжать цепочку по обычному
пути не имеет смысла. Наоборот, мы должны как можно скорее вывалиться из стека.</p>

<p>Стандартные врапперы из примеров выше работают на условиях. Так,
<code class="highlighter-rouge">wrap-json-params</code> читает тело только в том случае, если заголовок
<code class="highlighter-rouge">Content-Type</code> установлен в <code class="highlighter-rouge">application/json</code>. Если в нем что-то другое, он
оставит поток нетронутым. При разборе JSON-документа ловится возможное
исключение. Такое возможно, если документ сформирован с ошибками или поврежден
при передачи. В таком случае <code class="highlighter-rouge">wrap-json-params</code> не продолжает цепочку. Он
возвращает ответ с текстом “JSON body malformed”. Ни одно middleware ниже по
стеку не сработает.</p>

<p>Рассмотрим частный случай с проверкой доступа. Предположим, приложение доступно
только авторизованным пользователям. Мы уже определили текущего пользователя в
<code class="highlighter-rouge">wrap-current-user</code>. То middleware только определяет пользователя, но не
ограничивает доступ. Добавим ниже по стеку другое:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-auth-user-only</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="no">:user</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">403</span><span class="w">
       </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
       </span><span class="no">:body</span><span class="w"> </span><span class="s">"Please sign in to see that page."</span><span class="p">})))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь все middleware ниже <code class="highlighter-rouge">wrap-auth-user-only</code> не сработает если пользователь
не авторизован.</p>

<p>Вспомним, цепочку middleware можно представить как восхождение и спуск с
горы. Если один из элементов терпит неудачу, мы как будто срезаем
верхушку. Словно добрались до середины, столкнулись с проблемой и повернули
обратно. Общее правило: чем раньше мы обнаружим проблему, тем меньше потратим
сил. Поэтому более общие проверки мы ставим выше по стеку.</p>

<p>Еще один вариант middleware с развилкой это перехват ошибок. Это критически
важный обработчик. Вы не найдете его в стандартных библиотеках, потому что
логика работы с ошибками меняется от проекта к проекту. Мы просто копируем такой
middleware из прошлого проекта с небольшими изменениями.</p>

<p>Что случится, если при обработке запроса выброшено исключение? Не существует
четких правил на этот счет. Каждый сервер или фреймворк обрабатывает исключения.</p>

<p>Один сервер покажет в браузере стек-трейс. Другой сервер вернет HTML-страницу с
отладочной информацией. Разработчики третьего посчитали, что выводить стек-трейс
небезопасно. Исключение пишут в лог, а в ответе статус 500 и фраза “Internal
Server Error”.</p>

<p>Хорошо, когда разработчик сам определяет, что делать с исключениями. Ниже
простое middleware, которое перехватывает потенциальную ошибку, пишет ее в лог и
возвращает ответ-заглушку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">wrap-exception</span><span class="w">
  </span><span class="p">[</span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">request</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">try</span><span class="w">
      </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">uri</span><span class="w">
                      </span><span class="n">request-method</span><span class="p">]}</span><span class="w"> </span><span class="n">request</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nf">log/errorf</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="s">"Error, method %s, path %s"</span><span class="w">
                      </span><span class="n">request-method</span><span class="w"> </span><span class="n">uri</span><span class="p">)</span><span class="w">
          </span><span class="p">{</span><span class="no">:status</span><span class="w"> </span><span class="mi">500</span><span class="w">
           </span><span class="no">:headers</span><span class="w"> </span><span class="p">{</span><span class="no">:content-type</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">}</span><span class="w">
           </span><span class="no">:body</span><span class="w"> </span><span class="s">"Sorry, please try later."</span><span class="p">})))))</span><span class="w">
</span></code></pre></div></div>

<p>В примере выше <code class="highlighter-rouge">log/errorf</code> это макрос для записи ошибок. Он принимает объект
исключения, шаблон и параметры. Мы хотим знать, какие были метод и путь запроса,
поэтому записываем их тоже. Это значительно облегчит анализ логов в будущем.</p>

<p>Чем выше <code class="highlighter-rouge">wrap-exception</code> расположено в стеке, тем меньше шансов возникнуть не
пойманному исключению. В идеале оно стоит на вершине цепочки, чтобы
гарантированно ловить все исключения.</p>

<p>Порой даже используют стратегию двойного перехвата. Дело в том, что ошибки в
разных частях системы заслуживают разного подхода. Например, нам важно знать все
об ошибках в бизнес-логике. Если пользователь не смог создать сущность на
сервере, мы обязаны записать дату, номер пользователя, имя модуля и функции,
данные, которые вызвали ошибку. Возможно, этот случай запишут сразу в несколько
журналов. Но проблемы при чтении JSON-документа нас интересуют меньше. Это
техническая проблема, не связанная с бизнесом.</p>

<p>Чтобы разделять бизнес- и технические проблемы, на границах стека middleware
расставляют разные wrap-exception. Самое нижнее оборачивает непосредственно
app-naked. Оно отлавливает исключения в бизнес-логике. Такую ошибку обрабатывают
подробно, во всех деталях. На вершине стека другая, облегченная версия
wrap-exception. Его задача — ловить мелкие ошибки, связанные с предварительной
обработкой запроса. По большей части это для того, чтобы возвращать адекватный
ответ пользователю.</p>

<h3 id="middleware-вне-стека">Middleware вне стека</h3>

<p>Интересен сценарий, когда middleware должно оказать эффект только на запросы по
определенному пути. Вернемся к wrap-auth-user-only. В чем его недостаток? Если
включить его в стек, анонимный пользователь не увидит ни одну
страницу. Абсолютно любой запрос будет отклонен со статусом 403. Главная
страница, контактные данные, форма входа — все страницы недоступны. В этом нет
никакого смысла.</p>

<p>Очевидно, <code class="highlighter-rouge">wrap-auth-user-only</code> должен перекрывать только некоторое подмножество
запросов. Например, тех, что начинаются с <code class="highlighter-rouge">/account</code>: <code class="highlighter-rouge">/account/cart</code>,
<code class="highlighter-rouge">/account/orders</code> и т.д. Место <code class="highlighter-rouge">wrap-auth-user-only</code> не в общем стеке, а ниже —
на уровне роутинга.</p>

<p>Дальнейшая реализация зависит от того, как мы строим маршруты. В Compojure есть
особое middleware под названием wrap-routes. Оно принимает правило и другое
middleware. Если правило накладывается на текущий запрос, то целевой обработчик
оборачивается в переданное middleware. Столь сложная логика нужна, чтобы не
вызывать middleware, пока запрос не совпадет с правилом.</p>

<p>Вынесем семейство маршрутов для аккаунта в отдельную ветку:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defroutes</span><span class="w"> </span><span class="n">account-routes</span><span class="w">
  </span><span class="p">(</span><span class="nf">with-context</span><span class="w"> </span><span class="s">"/account"</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/profile"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">account-profile</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/orders"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">account-orders</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/cart"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">account-cart</span><span class="w"> </span><span class="n">request</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Обернем аккаунты в маршрутах верхнего уровня:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defroutes</span><span class="w"> </span><span class="n">app</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-index</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">GET</span><span class="w"> </span><span class="s">"/help"</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="p">(</span><span class="nf">page-help</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">wrap-routes</span><span class="w"> </span><span class="n">account-routes</span><span class="w"> </span><span class="n">wrap-auth-user-only</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Теперь <code class="highlighter-rouge">wrap-auth-user-only</code> сработает только для обработчиков
<code class="highlighter-rouge">account-profile</code>, <code class="highlighter-rouge">account-orders</code> и <code class="highlighter-rouge">account-cart</code>.</p>

<h3 id="Все-вместе">Все вместе</h3>

<p>Middleware, которое принимает middleware — довольно крутая абстракция. Если вы
действительно поняли, как это работает и почему именно так — примите
поздравления. Это серьезный рубеж.</p>

<p>Пожалуй, это все, что можно сказать о middleware. Небольшое обобщение: все, что
мы проделали выше работает на функциях. Типичное middleware это функция, которая
принимает функцию и возвращает функцию. Middleware — универсальный строительный
материал.</p>

<p>Цепочку middleware называют стеком. Во время запроса мы движемся по стеку снизу
вверх, во время ответа — сверху вниз. Такой обход можно сравнить с восхождением
в гору. Каждое middleware может прервать цепочку в зависимости от
обстоятельств. Легче всего выразить стек с помощью стрелочного оператора. Это
экономит скобки и делает структуру наглядней.</p>

  </div>

</article>

<div id="disqus_thread"></div>
<script>
    /**
    * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
    */
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');

    s.src = '//igrishaev.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ivan Grishaev's blog</li>
          <li><a href="mailto:ivan@grishaev.me">ivan@grishaev.me</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/igrishaev"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">igrishaev</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/i_grishaev"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">i_grishaev</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writing on programming, education, books and negotiations.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
